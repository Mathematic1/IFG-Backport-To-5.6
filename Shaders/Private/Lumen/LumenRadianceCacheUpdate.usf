// Copyright Epic Games, Inc. All Rights Reserved.

#include "../Common.ush"
#include "../ShaderPrint.ush"
#include "LumenRadianceCacheCommon.ush"
#include "LumenRadianceCacheMarkCommon.ush"
#include "LumenRadianceCacheUpdate.ush"
#include "LumenRadianceCacheTracingCommon.ush"

uint MaxNumProbes;
RWBuffer<uint> RWProbeLastUsedFrame;
RWBuffer<int> RWProbeFreeListAllocator;
RWBuffer<uint> RWProbeFreeList;
RWStructuredBuffer<float4> RWProbeWorldOffset;
RWBuffer<uint> RWProbeInterpolationMisses;
RWBuffer<uint> RWProbeCreatedFrame;

#ifdef ClearProbeFreeListCS

[numthreads(THREADGROUP_SIZE, 1, 1)]
void ClearProbeFreeListCS(
	uint3 GroupId : SV_GroupID,
	uint3 DispatchThreadId : SV_DispatchThreadID,
	uint3 GroupThreadId : SV_GroupThreadID)
{
	uint ThreadIndex = DispatchThreadId.x;

	if (ThreadIndex == 0)
	{
		RWProbeFreeListAllocator[0] = 0;
	}

	if (ThreadIndex < MaxNumProbes)
	{
		RWProbeFreeList[ThreadIndex] = 0;
		RWProbeLastUsedFrame[ThreadIndex] = 0;
		RWProbeWorldOffset[ThreadIndex] = 0;
		RWProbeCreatedFrame[ThreadIndex] = 0;

		#if ADAPTIVE_PROBES
			RWProbeInterpolationMisses[MaxNumProbes * 0 + ThreadIndex] = 0;
			RWProbeInterpolationMisses[MaxNumProbes * 1 + ThreadIndex] = 0;
			RWProbeInterpolationMisses[MaxNumProbes * 2 + ThreadIndex] = 0;
			RWProbeInterpolationMisses[MaxNumProbes * 3 + ThreadIndex] = 0;
		#endif
	}
}

#endif


uint FrameNumber;
RWBuffer<uint> RWProbeAdaptiveIndices;

#ifdef UpdateCacheForUsedProbesCS

Buffer<uint> ProbeAllocator;
Texture3D<uint> LastFrameRadianceProbeIndirectionTexture;
float4 LastFrameClipmapCornerTWSAndCellSize[RADIANCE_PROBE_MAX_CLIPMAPS];
uint NumFramesToKeepCachedProbes;

float3 GetLastFrameProbeTranslatedWorldPosition(uint3 LastFrameProbeCoord, uint ClipmapIndex)
{
	float3 CornerTranslatedWorldSpace = LastFrameClipmapCornerTWSAndCellSize[ClipmapIndex].xyz;
	float CellSize = LastFrameClipmapCornerTWSAndCellSize[ClipmapIndex].w;

	const float3 CornerToProbe = (LastFrameProbeCoord + 0.5) * CellSize;
	float3 PreViewTranslationOffset = DFFastLocalSubtractDemote(PrimaryView.PreViewTranslation, PrimaryView.PrevPreViewTranslation);
	return CornerTranslatedWorldSpace + CornerToProbe + PreViewTranslationOffset;
}

void FreeProbeIndex(uint ProbeIndex)
{
	int FreeIndex;
	InterlockedAdd(RWProbeFreeListAllocator[0], 1, FreeIndex);
	RWProbeFreeList[FreeIndex] = ProbeIndex;
	RWProbeCreatedFrame[ProbeIndex] = 0;
}

[numthreads(THREADGROUP_SIZE, THREADGROUP_SIZE, THREADGROUP_SIZE)]
void UpdateCacheForUsedProbesCS(
	uint3 GroupId : SV_GroupID,
	uint3 DispatchThreadId : SV_DispatchThreadID,
	uint3 GroupThreadId : SV_GroupThreadID)
{
	uint ClipmapIndex = DispatchThreadId.x / RadianceProbeClipmapResolution;
	uint3 LastFrameProbeCoord = uint3(DispatchThreadId.x - ClipmapIndex * RadianceProbeClipmapResolution, DispatchThreadId.yz);

	if (ClipmapIndex < NumRadianceProbeClipmaps && all(LastFrameProbeCoord < RadianceProbeClipmapResolution))
	{
		uint3 LastFrameProbeIndirectionTextureCoord = uint3(LastFrameProbeCoord.x + ClipmapIndex * RadianceProbeClipmapResolution, LastFrameProbeCoord.yz);
		FProbeIndirectionDesc LastFrameProbe = DecodeProbeIndirection(LastFrameRadianceProbeIndirectionTexture.Load(uint4(LastFrameProbeIndirectionTextureCoord, 0)));

		if (LastFrameProbe.bValid)
		{
			float3 ProbeTranslatedWorldPosition = GetLastFrameProbeTranslatedWorldPosition(LastFrameProbeCoord, ClipmapIndex);
			int3 ProbeCoord = GetRadianceProbeCoord(ProbeTranslatedWorldPosition, ClipmapIndex);

			bool bReused = false;

			if (all(ProbeCoord >= 0) && all(ProbeCoord < (int3)RadianceProbeClipmapResolution))
			{
				uint3 ProbeIndirectionTextureCoord = uint3(ProbeCoord.x + ClipmapIndex * RadianceProbeClipmapResolution, ProbeCoord.yz);
				uint ProbeUsedMarker = RWRadianceProbeIndirectionTexture[ProbeIndirectionTextureCoord];
				uint LastUsedFrameNumber = RWProbeLastUsedFrame[LastFrameProbe.ProbeIndex];

				uint NumFramesToKeepCachedProbesHeuristic = NumFramesToKeepCachedProbes;

				// Make sure that it's possible to allocate at least NumProbesToTraceBudget probes this frame
				const uint NumFreeProbes = MaxNumProbes - ProbeAllocator[0] + RWProbeFreeListAllocator[0];
				if (NumFreeProbes < NumProbesToTraceBudget)
				{
					NumFramesToKeepCachedProbesHeuristic = min(2, NumFramesToKeepCachedProbes);
				}

				if (ProbeUsedMarker == USED_PROBE_INDEX
					|| FrameNumber - LastUsedFrameNumber < NumFramesToKeepCachedProbes)
				{
					bReused = true;

					if (ProbeUsedMarker == USED_PROBE_INDEX)
					{
						RWProbeLastUsedFrame[LastFrameProbe.ProbeIndex] = FrameNumber;
					}
	
					#if ADAPTIVE_PROBES
						uint CompactedIndex = 0;
						// Free adaptive probes if they haven't been used and compact the list
						for (uint i = 0; i < LastFrameProbe.NumAdaptiveProbes; i++)
						{
							uint AdaptiveProbeIndex = RWProbeAdaptiveIndices[LastFrameProbe.ProbeIndex * MAX_ADAPTIVE_PROBES + i];
							uint LastUsedFrameNumber = RWProbeLastUsedFrame[AdaptiveProbeIndex];

							if (FrameNumber - LastUsedFrameNumber >= NumFramesToKeepCachedProbes)
							{
								FreeProbeIndex(AdaptiveProbeIndex);
							}
							else
							{
								if (i != CompactedIndex)
								{
									RWProbeAdaptiveIndices[LastFrameProbe.ProbeIndex * MAX_ADAPTIVE_PROBES + CompactedIndex] = AdaptiveProbeIndex;
								}
							
								CompactedIndex++;
							}
						}
			
						LastFrameProbe.NumAdaptiveProbes = CompactedIndex;
					#endif

					RWRadianceProbeIndirectionTexture[ProbeIndirectionTextureCoord] = EncodeProbeIndirection(LastFrameProbe);
				}
			}

			if (!bReused)
			{
				FreeProbeIndex(LastFrameProbe.ProbeIndex);

				#if ADAPTIVE_PROBES
				for (uint i = 0; i < LastFrameProbe.NumAdaptiveProbes; i++)
				{
					FreeProbeIndex(RWProbeAdaptiveIndices[LastFrameProbe.ProbeIndex * MAX_ADAPTIVE_PROBES + i]);
				}
				#endif
			}
		}
	}
}

#endif

float FirstClipmapWorldExtentRcp;
RWStructuredBuffer<uint> RWPriorityHistogram;
StructuredBuffer<uint> PriorityHistogram;
RWStructuredBuffer<uint> RWMaxUpdateBucket;
StructuredBuffer<uint> MaxUpdateBucket;
RWStructuredBuffer<uint> RWMaxTracesFromMaxUpdateBucket;
StructuredBuffer<uint> MaxTracesFromMaxUpdateBucket;
RWStructuredBuffer<uint> RWProbesToUpdateTraceCost;
StructuredBuffer<uint> ProbesToUpdateTraceCost;
RWStructuredBuffer<uint> RWMinNewProbeTraceCost;

RWStructuredBuffer<uint> RWProbeLastTracedFrame;
Buffer<uint> ProbeLastUsedFrame;

RWBuffer<uint> RWProbeAllocator;
Buffer<uint> ProbeFreeList;

RWBuffer<uint> RWProbeTraceAllocator;
Buffer<uint> ProbeTraceAllocator;
RWBuffer<float4> RWProbeTraceData;

#ifdef ClearRadianceCacheUpdateResourcesCS

/**
 * Batch clear all resources required for the subsequent radiance cache probe update pass
 */
[numthreads(THREADGROUP_SIZE, 1, 1)]
void ClearRadianceCacheUpdateResourcesCS(
	uint3 DispatchThreadId : SV_DispatchThreadID)
{
	uint ElementIndex = DispatchThreadId.x;

	if (ElementIndex < 1)
	{
		RWProbeTraceAllocator[ElementIndex] = 0;
		RWMaxUpdateBucket[ElementIndex] = 0;
		RWMaxTracesFromMaxUpdateBucket[ElementIndex] = 0;
		RWMinNewProbeTraceCost[ElementIndex] = 0;
	}

	if (ElementIndex < PROBES_TO_UPDATE_TRACE_COST_STRIDE)
	{
		RWProbesToUpdateTraceCost[ElementIndex] = 0;
	}

	if (ElementIndex < PRIORITY_HISTOGRAM_SIZE)
	{
		RWPriorityHistogram[ElementIndex] = 0;
	}
}

#endif

uint GetPriorityBucketIndex(uint LastTracedFrameIndex, uint LastUsedFrameIndex, uint ClipmapIndex)
{
	uint BucketIndex = 0;

	if (LastTracedFrameIndex == PROBE_FRAME_INDEX_NEVER_TRACED)
	{
		// Special case for probes which were created this frame. Places those in the most important bucket 0.
		BucketIndex = 0;
	}
	else
	{
		// [1;N]
		uint FramesBetweenTracedAndUsed = LastUsedFrameIndex > LastTracedFrameIndex ? LastUsedFrameIndex - LastTracedFrameIndex : 1;
		float UpdateImportance = FramesBetweenTracedAndUsed / (ClipmapIndex + 1.0f);

		// Remap from [1;N] to log2 histogram buckets, but don't write anything to special bucket 0 used for new probes without any data
		BucketIndex = PRIORITY_HISTOGRAM_SIZE - 1 - clamp(log2(UpdateImportance), 0, PRIORITY_HISTOGRAM_SIZE - 2);
	}

	return BucketIndex;
}

#ifdef AllocateUsedProbesCS

uint AllocateProbeIndex()
{
	uint ProbeIndex;

	#if PERSISTENT_CACHE
		int NumFree;
		InterlockedAdd(RWProbeFreeListAllocator[0], -1, NumFree);

		if (NumFree > 0)
		{
			ProbeIndex = ProbeFreeList[NumFree - 1];
		}
		else
		{
			InterlockedAdd(RWProbeAllocator[0], 1, ProbeIndex);
		}
	#else
		InterlockedAdd(RWProbeAllocator[0], 1, ProbeIndex);
	#endif

	return ProbeIndex;
}

Buffer<uint> LastFrameProbeInterpolationMisses;

void UpdatePriorityHistogram(uint LastTracedFrameIndex, uint LastUsedFrameIndex, uint ClipmapIndex, uint3 ProbeCoord)
{
	// Update histogram
	const uint PriorityBucketIndex = GetPriorityBucketIndex(LastTracedFrameIndex, LastUsedFrameIndex, ClipmapIndex);
	const float3 ProbeTranslatedWorldPosition = GetProbeTranslatedWorldPositionNoOffset(ProbeCoord, ClipmapIndex);
	uint ProbeTraceCost = GetProbeTraceCost(ProbeTranslatedWorldPosition);
	InterlockedAdd(RWPriorityHistogram[PriorityBucketIndex], ProbeTraceCost);

	if (PriorityBucketIndex == 0)
	{
		// Cost of updating all probes in the first bucket if they would be all force downsampled
		InterlockedAdd(RWMinNewProbeTraceCost[0], PROBE_TRACE_COST_DOWNSAMPLED);
	}
}

/** 
 * Allocate used probes and build their update priority histogram
 */
[numthreads(THREADGROUP_SIZE, THREADGROUP_SIZE, THREADGROUP_SIZE)]
void AllocateUsedProbesCS(
	uint3 GroupId : SV_GroupID,
	uint3 DispatchThreadId : SV_DispatchThreadID,
	uint3 GroupThreadId : SV_GroupThreadID)
{
	uint ClipmapIndex = DispatchThreadId.x / RadianceProbeClipmapResolution;
	uint3 ProbeCoord = uint3(DispatchThreadId.x - ClipmapIndex * RadianceProbeClipmapResolution, DispatchThreadId.y, DispatchThreadId.z);

	if (ClipmapIndex < NumRadianceProbeClipmaps && all(ProbeCoord < RadianceProbeClipmapResolution))
	{
		uint EncodedProbeIndirection = RWRadianceProbeIndirectionTexture[DispatchThreadId];

		if (EncodedProbeIndirection != INVALID_PROBE_INDEX)
		{
			FProbeIndirectionDesc ProbeIndirection;
			ProbeIndirection.ProbeIndex = INVALID_PROBE_INDEX;
			ProbeIndirection.NumAdaptiveProbes = 0;
			ProbeIndirection.bValid = false;

			// If the probe is marked as used but wasn't modified in UpdateCacheForUsedProbesCS then we need to allocate a new probe
			if (EncodedProbeIndirection == USED_PROBE_INDEX)
			{
				ProbeIndirection.ProbeIndex = AllocateProbeIndex();
				ProbeIndirection.bValid = true;

				if (ProbeIndirection.ProbeIndex < MaxNumProbes)
				{
					uint LastTracedFrameIndex = PROBE_FRAME_INDEX_NEVER_TRACED;
					uint LastUsedFrameIndex = FrameNumber;

					RWProbeLastTracedFrame[ProbeIndirection.ProbeIndex] = LastTracedFrameIndex;
					RWProbeLastUsedFrame[ProbeIndirection.ProbeIndex] = LastUsedFrameIndex;
					RWProbeCreatedFrame[ProbeIndirection.ProbeIndex] = FrameNumber;
					RWProbeWorldOffset[ProbeIndirection.ProbeIndex] = 0;

					UpdatePriorityHistogram(LastTracedFrameIndex, LastUsedFrameIndex, ClipmapIndex, ProbeCoord);
				}
			}
			else
			{
				// Re-trace existing probe
				ProbeIndirection = DecodeProbeIndirection(EncodedProbeIndirection);
				uint LastTracedFrameIndex = RWProbeLastTracedFrame[ProbeIndirection.ProbeIndex];
				uint LastUsedFrameIndex = RWProbeLastUsedFrame[ProbeIndirection.ProbeIndex];

				UpdatePriorityHistogram(LastTracedFrameIndex, LastUsedFrameIndex, ClipmapIndex, ProbeCoord);

				#if ADAPTIVE_PROBES
				// Update histogram for this probe's adaptive probes
				for (uint i = 0; i < ProbeIndirection.NumAdaptiveProbes; i++)
				{
					uint AdaptiveProbeIndex = RWProbeAdaptiveIndices[ProbeIndirection.ProbeIndex * MAX_ADAPTIVE_PROBES + i];
					uint AdaptiveLastTracedFrameIndex = RWProbeLastTracedFrame[AdaptiveProbeIndex];
					uint AdaptiveLastUsedFrameIndex = RWProbeLastUsedFrame[AdaptiveProbeIndex];

					UpdatePriorityHistogram(AdaptiveLastTracedFrameIndex, AdaptiveLastUsedFrameIndex, ClipmapIndex, ProbeCoord);
				}

				uint NumProbeInterpolationMisses = LastFrameProbeInterpolationMisses[ProbeIndirection.ProbeIndex];

				// Allocate a new adaptive probe if there were enough interpolation misses last frame
				if (NumProbeInterpolationMisses > 4 && ProbeIndirection.NumAdaptiveProbes < MAX_ADAPTIVE_PROBES)
				{
					uint AdaptiveProbeIndex = AllocateProbeIndex();

					if (AdaptiveProbeIndex < MaxNumProbes)
					{
						uint AdaptiveLastTracedFrameIndex = PROBE_FRAME_INDEX_NEVER_TRACED;
						uint AdaptiveLastUsedFrameIndex = FrameNumber;

						RWProbeLastTracedFrame[AdaptiveProbeIndex] = AdaptiveLastTracedFrameIndex;
						RWProbeLastUsedFrame[AdaptiveProbeIndex] = AdaptiveLastUsedFrameIndex;

						UpdatePriorityHistogram(AdaptiveLastTracedFrameIndex, AdaptiveLastUsedFrameIndex, ClipmapIndex, ProbeCoord);

						RWProbeAdaptiveIndices[ProbeIndirection.ProbeIndex * MAX_ADAPTIVE_PROBES + ProbeIndirection.NumAdaptiveProbes] = AdaptiveProbeIndex;

						float CellPrecision = 128.0f;
						float2 QuantizeScaleAndBias = CellPrecision * float2(.5f / GetRadianceProbeClipmapCellSize(ClipmapIndex), .5f);
						//uint3 QuantizedIdealProbeOffset = round(IdealProbeOffset * QuantizeScaleAndBias.x + QuantizeScaleAndBias.y);
						float3 AccumulatedIdealProbePosition = (float3(
							LastFrameProbeInterpolationMisses[1 * MaxNumProbes + ProbeIndirection.ProbeIndex], 
							LastFrameProbeInterpolationMisses[2 * MaxNumProbes + ProbeIndirection.ProbeIndex], 
							LastFrameProbeInterpolationMisses[3 * MaxNumProbes + ProbeIndirection.ProbeIndex]) / (float)NumProbeInterpolationMisses - QuantizeScaleAndBias.y) / QuantizeScaleAndBias.x;
						RWProbeWorldOffset[AdaptiveProbeIndex] = float4(AccumulatedIdealProbePosition, 0);
						ProbeIndirection.NumAdaptiveProbes++;
					}
				}
				#endif
			}

			if (ProbeIndirection.ProbeIndex < MaxNumProbes)
			{
				RWRadianceProbeIndirectionTexture[DispatchThreadId] = EncodeProbeIndirection(ProbeIndirection);
			}
			else
			{
				RWRadianceProbeIndirectionTexture[DispatchThreadId] = INVALID_PROBE_INDEX;
			}
		}
	}
}

#endif

#ifdef SelectMaxPriorityBucketCS

/** 
 * Compute max bucket histogram to update and how many tiles should be updated in that last bucket 
 */
[numthreads(THREADGROUP_SIZE, 1, 1)]
void SelectMaxPriorityBucketCS(
	uint3 GroupId : SV_GroupID,
	uint3 GroupThreadId : SV_GroupThreadID,
	uint3 DispatchThreadId : SV_DispatchThreadID)
{
	if (all(DispatchThreadId == 0))
	{
		uint NumTracesBudget = GetProbeTraceCostBudget();
		uint TraceSum = 0;
		uint PriorityBucketIndex = 0;
		uint NumTracesFromPriorityBucket = NumTracesBudget;

		for (; PriorityBucketIndex < PRIORITY_HISTOGRAM_SIZE; ++PriorityBucketIndex)
		{
			uint TilesPerBucket = PriorityHistogram[PriorityBucketIndex];

			if (TraceSum + TilesPerBucket >= NumTracesBudget)
			{
				NumTracesFromPriorityBucket = NumTracesBudget - TraceSum;
				break;
			}

			TraceSum += TilesPerBucket;
		}

		RWMaxUpdateBucket[0] = PriorityBucketIndex;
		RWMaxTracesFromMaxUpdateBucket[0] = NumTracesFromPriorityBucket;
	}
}

#endif

#ifdef AllocateProbeTracesCS

Buffer<uint> ProbeAdaptiveIndices;

void AllocateProbeTraces(uint ProbeTraceCost, uint ProbeIndex, uint ClipmapIndex, uint3 ProbeCoord)
{
	if (ProbeIndex < MaxNumProbes)
	{
		const uint MaxUpdateBucketIndex = MaxUpdateBucket[0];
		const uint LocalMaxTracesFromMaxUpdateBucket = MaxTracesFromMaxUpdateBucket[0];
		const uint LastTracedFrameIndex = RWProbeLastTracedFrame[ProbeIndex];
		const uint LastUsedFrameIndex = ProbeLastUsedFrame[ProbeIndex];

		// Update everything up to the max selected priority bucket
		const uint PriorityBucketIndex = GetPriorityBucketIndex(LastTracedFrameIndex, LastUsedFrameIndex, ClipmapIndex);

		bool bTraceProbe = PriorityBucketIndex <= MaxUpdateBucketIndex;
		bool bForceDownsampleProbe = false;

		// Can't trace more than MaxTracesFromMaxUpdateBucket from the last bucket
        if (bTraceProbe)
        {
			if (PriorityBucketIndex == MaxUpdateBucketIndex && MaxUpdateBucketIndex > 0)
            {
                // Accumulate allocated probe trace cost for the last bucket
                uint ProbeTraceAllocatedFromMaxUpdateBucket = 0;
                InterlockedAdd(RWProbesToUpdateTraceCost[1], ProbeTraceCost, ProbeTraceAllocatedFromMaxUpdateBucket);

                if (ProbeTraceAllocatedFromMaxUpdateBucket + ProbeTraceCost > LocalMaxTracesFromMaxUpdateBucket)
                {
                    bTraceProbe = false;
                }
            }
			else if (PriorityBucketIndex == 0)
			{
				// Special case for the first bucket.
				// It contains probes without valid data so all those probes need to be updated.

				uint PrevMinNewProbeTraceCost = 0;
                InterlockedAdd(RWMinNewProbeTraceCost[0], ProbeTraceCost - PROBE_TRACE_COST_DOWNSAMPLED, PrevMinNewProbeTraceCost);

				// Downsample anything exceeding allowed budget in order to keep performance reasonable
				if (PrevMinNewProbeTraceCost + ProbeTraceCost - PROBE_TRACE_COST_DOWNSAMPLED > GetProbeTraceCostBudget())
				{
					bForceDownsampleProbe = true;
				}
			}
        }
			
		if (bTraceProbe)
		{
			InterlockedAdd(RWProbesToUpdateTraceCost[0], ProbeTraceCost);

			uint TraceIndex;
			InterlockedAdd(RWProbeTraceAllocator[0], 1, TraceIndex); 
			float3 ProbeTranslatedWorldPosition = GetProbeTranslatedWorldPositionNoOffset(ProbeCoord, ClipmapIndex);
			RWProbeTraceData[TraceIndex] = PackProbeTraceData(ProbeTranslatedWorldPosition, ClipmapIndex, ProbeIndex, bForceDownsampleProbe);
			RWProbeLastTracedFrame[ProbeIndex] = FrameNumber;
		}
	}
}

/**
 * Iterate again over all probes and update them based on the histogram priority max update bucket
 */
[numthreads(THREADGROUP_SIZE, THREADGROUP_SIZE, THREADGROUP_SIZE)]
void AllocateProbeTracesCS(
	uint3 GroupId : SV_GroupID,
	uint3 DispatchThreadId : SV_DispatchThreadID,
	uint3 GroupThreadId : SV_GroupThreadID)
{
	uint ClipmapIndex = DispatchThreadId.x / RadianceProbeClipmapResolution;
	uint3 ProbeCoord = uint3(DispatchThreadId.x - ClipmapIndex * RadianceProbeClipmapResolution, DispatchThreadId.y, DispatchThreadId.z);

	if (ClipmapIndex < NumRadianceProbeClipmaps && all(ProbeCoord < RadianceProbeClipmapResolution))
	{
		const FProbeIndirectionDesc ProbeIndirection = DecodeProbeIndirection(RadianceProbeIndirectionTexture[DispatchThreadId]);
		float3 ProbeTranslatedWorldPositionForCost = GetProbeTranslatedWorldPositionNoOffset(ProbeCoord, ClipmapIndex);
		const uint ProbeTraceCost = GetProbeTraceCost(ProbeTranslatedWorldPositionForCost);

		AllocateProbeTraces(ProbeTraceCost, ProbeIndirection.ProbeIndex, ClipmapIndex, ProbeCoord);

		#if ADAPTIVE_PROBES
		//@todo - always downsample adaptive probes
		for (uint i = 0; i < ProbeIndirection.NumAdaptiveProbes; i++)
		{
			uint AdaptiveProbeIndex = ProbeAdaptiveIndices[ProbeIndirection.ProbeIndex * MAX_ADAPTIVE_PROBES + i];
			AllocateProbeTraces(ProbeTraceCost, AdaptiveProbeIndex, ClipmapIndex, ProbeCoord);
		}
		#endif
	}
}

#endif
