// Copyright Epic Games, Inc. All Rights Reserved.

#include "../Common.ush"
#include "../MonteCarlo.ush"
#include "../FastMath.ush"
#include "../SHCommon.ush"
#include "../DeferredShadingCommon.ush"
#include "LumenCardCommon.ush"
#include "LumenTracingCommon.ush"
#include "LumenSoftwareRayTracing.ush"
#include "LumenIrradianceFieldInterpolation.ush"
#include "LumenRadianceCacheCommon.ush"
#include "LumenRadianceCacheMarkCommon.ush"
#include "LumenRadianceCacheTracingCommon.ush"
#include "LumenScreenProbeCommon.ush"
#include "LumenScreenProbeImportanceSamplingShared.ush"
#include "LumenRadianceCacheUpdate.ush"
#include "LumenMaterial.ush"

#ifndef THREADGROUP_SIZE
#define THREADGROUP_SIZE 1
#endif

#ifdef ClearProbeIndirectionCS

[numthreads(THREADGROUP_SIZE, THREADGROUP_SIZE, THREADGROUP_SIZE)]
void ClearProbeIndirectionCS(
	uint3 GroupId : SV_GroupID,
	uint3 DispatchThreadId : SV_DispatchThreadID,
	uint3 GroupThreadId : SV_GroupThreadID)
{
	RWRadianceProbeIndirectionTexture[DispatchThreadId] = INVALID_PROBE_INDEX;
}

#endif

RWBuffer<float4> RWProbeWorldOffset;


RWBuffer<int> RWProbeFreeListAllocator;
RWBuffer<uint> RWProbeFreeList;
uint MaxNumProbes;

float MinTraceDistance;
float MaxTraceDistance;

#ifdef MarkRadianceProbesUsedByVisualizeCS

[numthreads(1, 1, 1)]
void MarkRadianceProbesUsedByVisualizeCS(
	uint3 GroupId : SV_GroupID,
	uint3 DispatchThreadId : SV_DispatchThreadID,
	uint3 GroupThreadId : SV_GroupThreadID)
{
	// For visualize mode, generate probes around the camera position
	uint ClipmapIndex = GetRadianceProbeClipmapForMark(PrimaryView.TranslatedWorldCameraOrigin, .5f);

	if (IsValidRadianceCacheClipmapForMark(ClipmapIndex))
	{
		MarkPositionUsedInIndirectionTexture(PrimaryView.TranslatedWorldCameraOrigin, ClipmapIndex);
	}
}

#endif

// Must match C++
#define NUM_RADIANCE_PROBE_PDF_COEFFICIENTS (NUM_PDF_SH_COEFFICIENTS + 1)


RWBuffer<uint> RWProbeAllocator;
RWBuffer<uint> RWClearProbePDFsIndirectArgs;
RWBuffer<uint> RWGenerateProbeTraceTilesIndirectArgs;
RWBuffer<uint> RWGenerateUniformProbeTraceTilesIndirectArgs;
RWBuffer<uint> RWProbeTraceTileAllocator;
RWBuffer<uint> RWFilterProbesIndirectArgs;
RWBuffer<uint> RWPrepareProbeOcclusionIndirectArgs;
RWBuffer<uint> RWFixupProbeBordersIndirectArgs;
Buffer<uint> ProbeTraceAllocator;
uint ClearProbePDFGroupSize;
uint TraceFromProbesGroupSizeXY;
uint FilterProbesGroupSizeXY;
uint GenerateUniformProbeTraceTilesGroupSize;

#ifdef SetupProbeIndirectArgsCS

[numthreads(1, 1, 1)]
void SetupProbeIndirectArgsCS()
{
	// Clamp allocators
	if (RWProbeFreeListAllocator[0] < 0)
	{
		RWProbeFreeListAllocator[0] = 0;
	}

	if (RWProbeFreeListAllocator[0] > (int)MaxNumProbes)
	{
		RWProbeFreeListAllocator[0] = (int)MaxNumProbes;
	}

	if (RWProbeAllocator[0] > MaxNumProbes)
	{
		RWProbeAllocator[0] = MaxNumProbes;
	}

	uint NumProbesToTrace = ProbeTraceAllocator[0];

	WriteDispatchIndirectArgs(RWClearProbePDFsIndirectArgs, 0,
		(NumProbesToTrace * NUM_RADIANCE_PROBE_PDF_COEFFICIENTS + ClearProbePDFGroupSize - 1) / ClearProbePDFGroupSize,
		1,
		1);

	WriteDispatchIndirectArgs(RWGenerateProbeTraceTilesIndirectArgs, 0, 1, 1, NumProbesToTrace);

	WriteDispatchIndirectArgs(RWGenerateUniformProbeTraceTilesIndirectArgs, 0, (NumProbesToTrace + GenerateUniformProbeTraceTilesGroupSize - 1) / GenerateUniformProbeTraceTilesGroupSize, 1, 1);

	RWProbeTraceTileAllocator[0] = 0;

	WriteDispatchIndirectArgs(RWFilterProbesIndirectArgs, 0,
		(RadianceProbeResolution + FilterProbesGroupSizeXY - 1) / FilterProbesGroupSizeXY,
		(RadianceProbeResolution + FilterProbesGroupSizeXY - 1) / FilterProbesGroupSizeXY,
		NumProbesToTrace);

	WriteDispatchIndirectArgs(RWPrepareProbeOcclusionIndirectArgs, 0,
		1,
		1,
		NumProbesToTrace);

	WriteDispatchIndirectArgs(RWFixupProbeBordersIndirectArgs, 0,
		(FinalProbeResolution + TraceFromProbesGroupSizeXY - 1) / TraceFromProbesGroupSizeXY,
		(FinalProbeResolution + TraceFromProbesGroupSizeXY - 1) / TraceFromProbesGroupSizeXY,
		NumProbesToTrace);
}

#endif

#ifdef ComputeProbeWorldOffsetsCS

Buffer<float4> ProbeTraceData;

groupshared float4 SharedBestOffset[THREADGROUP_SIZE];
groupshared float4 SharedBestOffset2[THREADGROUP_SIZE];
groupshared uint4 SharedIdealProbeOffset;

[numthreads(THREADGROUP_SIZE, 1, 1)]
void ComputeProbeWorldOffsetsCS(
	uint3 GroupId : SV_GroupID,
	uint GroupThreadId : SV_GroupThreadID)
{
	uint ProbeTraceIndex = GroupId.z;

	FProbeTraceData TraceData = GetProbeTraceDataNoOffset(ProbeTraceData[ProbeTraceIndex]);
	const float3 ProbeTranslatedWorldCenter = TraceData.ProbeTranslatedWorldCenter + RWProbeWorldOffset[TraceData.ProbeIndex].xyz;
	float CellSize = GetRadianceProbeClipmapCellSize(TraceData.ClipmapIndex);

#if OFFSET_USING_GBUFFER
	
	float CellPrecision = 128.0f;
	
	if (GroupThreadId == 0)
	{
		SharedIdealProbeOffset = 0;
	}

	GroupMemoryBarrierWithGroupSync();

	{
		float4 ProbeProjectedPosition = mul(float4(ProbeTranslatedWorldCenter, 1.0f), View.TranslatedWorldToClip);
		float2 ProbeScreenPosition = ProbeProjectedPosition.xy / ProbeProjectedPosition.w;
		float2 ProbeScreenUV = ProbeScreenPosition * View.ScreenPositionScaleBias.xy + View.ScreenPositionScaleBias.wz;

		float KernelWidth = 16.0f;
		float2 SampleScreenOffset = GroupThreadId == 0 ? float2(0.0f, 0.0f) : (Hammersley16(GroupThreadId, THREADGROUP_SIZE, 0) - .5f) * KernelWidth;
		float2 SampleScreenUV = ProbeScreenUV + SampleScreenOffset * View.BufferSizeAndInvSize.zw;
		int2 SampleSvPosition = SampleScreenUV * View.BufferSizeAndInvSize.xy;

		if (all(SampleSvPosition.xy >= (int2)View.ViewRectMinAndSize.xy) && all(SampleSvPosition.xy < View.ViewRectMinAndSize.xy + View.ViewRectMinAndSize.zw))
		{
			float SampleSceneDepth = CalcSceneDepth(SampleScreenUV);

			if (ProbeProjectedPosition.w > SampleSceneDepth - .05f * CellSize)
			{
				float3 SampleTranslatedWorldPosition = GetTranslatedWorldPositionFromScreenUV(SampleScreenUV, SampleSceneDepth);
				float3 V = -GetCameraVectorFromTranslatedWorldPosition(SampleTranslatedWorldPosition);		
				FLumenMaterialData SampleMaterialData = ReadMaterialData(SampleSvPosition, SampleScreenUV, false);

				if (SampleMaterialData.IsValid())
				{
					float ProbeBias = .25f; 
					float3 IdealProbeOffset = (SampleMaterialData.WorldNormal * .2f + V * .8f) * (.75f * CellSize * ProbeBias);
		
					float3 IdealProbeTranslatedWorldPosition = SampleTranslatedWorldPosition + IdealProbeOffset;
					float MaxOffset = .25f * CellSize;	
					float3 SampleWorldOffset = IdealProbeTranslatedWorldPosition - TraceData.ProbeTranslatedWorldCenter;

					if (all(abs(SampleWorldOffset) < MaxOffset))
					{
						InterlockedAdd(SharedIdealProbeOffset.w, 1);

						float2 QuantizeScaleAndBias = CellPrecision * float2(.5f / CellSize, .5f);
						uint3 QuantizedIdealProbeOffset = clamp(round(SampleWorldOffset * QuantizeScaleAndBias.x + QuantizeScaleAndBias.y), 0.0f, CellPrecision);
						InterlockedAdd(SharedIdealProbeOffset.x, QuantizedIdealProbeOffset.x);
						InterlockedAdd(SharedIdealProbeOffset.y, QuantizedIdealProbeOffset.y);
						InterlockedAdd(SharedIdealProbeOffset.z, QuantizedIdealProbeOffset.z);
					}
				}
			}
		}
	}

	GroupMemoryBarrierWithGroupSync();	

	if (GroupThreadId == 0)
	{
		float NumSamples = SharedIdealProbeOffset.w;
		
		if (NumSamples > 0.0f)
		{
			float2 QuantizeScaleAndBias = CellPrecision * float2(.5f / CellSize, .5f);

			float3 AccumulatedIdealProbePosition = (SharedIdealProbeOffset.xyz / NumSamples - QuantizeScaleAndBias.y) / QuantizeScaleAndBias.x;
			RWProbeWorldOffset[TraceData.ProbeIndex] = float4(AccumulatedIdealProbePosition, 1);
		}
	}

#else

	float DistanceToSurface = GetDistanceToNearestSurfaceGlobal(ProbeTranslatedWorldCenter);
	float TooCloseThreshold = .05f * CellSize;

	if (DistanceToSurface < TooCloseThreshold)
	{
		float MaxVoxelOffset = .25f;

		uint X = GroupThreadId % 4;
		uint Y = (GroupThreadId % 16) / 4;
		uint Z = GroupThreadId / 16;
		{
			float3 Offset = (float3(X, Y, Z) * 2.0f / 3.0f - 1.0f) * MaxVoxelOffset * CellSize;
			float SampleDistanceToSurface = GetDistanceToNearestSurfaceGlobal(ProbeTranslatedWorldCenter + Offset);
			SharedBestOffset[GroupThreadId] = float4(Offset, SampleDistanceToSurface);
		}

		GroupMemoryBarrierWithGroupSync();

		if (GroupThreadId < 8)
		{
			float4 BestOffset = SharedBestOffset[GroupThreadId * 8];

			for (uint i = 1; i < 8; i++)
			{
				if (SharedBestOffset[GroupThreadId * 8 + i].w > BestOffset.w)
				{
					BestOffset = SharedBestOffset[GroupThreadId * 8 + i];
				}
			}
		
			SharedBestOffset2[GroupThreadId] = BestOffset;
		}

		GroupMemoryBarrierWithGroupSync();

		if (GroupThreadId == 0)
		{
			float4 BestOffset = SharedBestOffset2[0];

			for (uint i = 1; i < 8; i++)
			{
				if (SharedBestOffset2[i].w > BestOffset.w)
				{
					BestOffset = SharedBestOffset2[i];
				}
			}

			if (BestOffset.w >= TooCloseThreshold)
			{
				RWProbeWorldOffset[TraceData.ProbeIndex] = float4(BestOffset.xyz, 0);
			}
		}
		
		//RWProbeWorldOffset[TraceData.ProbeIndex] = float4(100, 100, 100, 0);
	}
#endif
}

#endif

RWBuffer<int> RWRadianceProbeSH_PDF;

#ifdef ClearProbePDFs

Buffer<float4> ProbeTraceData;

[numthreads(THREADGROUP_SIZE, 1, 1)]
void ClearProbePDFs(uint DispatchThreadId : SV_DispatchThreadID)
{
	uint ProbeTraceIndex = DispatchThreadId / NUM_RADIANCE_PROBE_PDF_COEFFICIENTS;
	uint ProbeIndex = GetProbeIndexFromProbeTraceData(ProbeTraceData[ProbeTraceIndex]);
	uint CoefficientIndex = DispatchThreadId - ProbeTraceIndex * NUM_RADIANCE_PROBE_PDF_COEFFICIENTS;

	RWRadianceProbeSH_PDF[ProbeIndex * NUM_RADIANCE_PROBE_PDF_COEFFICIENTS + CoefficientIndex] = 0;
}

#endif

#ifdef ScatterScreenProbeBRDFToRadianceProbesCS

[numthreads(THREADGROUP_SIZE, THREADGROUP_SIZE, 1)]
void ScatterScreenProbeBRDFToRadianceProbesCS(
	uint3 GroupId : SV_GroupID,
	uint3 GroupThreadId : SV_GroupThreadID)
{
	// PDF pass: Accumulate BRDF SH from screen probes
	// 	Scatter: Scatter BRDF SH into 8 radiance probes using atomics to buffer
	// 		Threadgroup per probe

	uint2 ScreenProbeAtlasCoord = GroupId.xy;
	
	uint ScreenProbeIndex = ScreenProbeAtlasCoord.y * ScreenProbeAtlasViewSize.x + ScreenProbeAtlasCoord.x;
	uint2 ScreenProbeScreenPosition = GetScreenProbeScreenPosition(ScreenProbeIndex);

	if (ScreenProbeIndex < GetNumScreenProbes() && ScreenProbeAtlasCoord.x < ScreenProbeAtlasViewSize.x)
	{
		float2 ScreenUV = GetScreenUVFromScreenProbePosition(ScreenProbeScreenPosition);
		float SceneDepth = GetScreenProbeDepth(ScreenProbeAtlasCoord);

		if (SceneDepth > 0)
		{
			float3 TranslatedWorldPosition = GetTranslatedWorldPositionFromScreenUV(ScreenUV, SceneDepth);
			uint2 ScreenTileCoord = GetScreenTileCoord(ScreenProbeScreenPosition);
			uint ClipmapIndex = GetRadianceProbeClipmap(TranslatedWorldPosition, 0);

			if (ClipmapIndex < NumRadianceProbeClipmaps)
			{
				int3 BottomCornerProbeCoord = GetRadianceProbeBottomCornerCoord(TranslatedWorldPosition, ClipmapIndex);
				int3 IndirectionTextureCoord = BottomCornerProbeCoord + int3(ClipmapIndex * RadianceProbeClipmapResolution, 0, 0);
				uint3 NeighborProbeCoord = BottomCornerProbeCoord + int3(GroupThreadId.x & 0x1, (GroupThreadId.x & 0x2) >> 1, (GroupThreadId.x & 0x4) >> 2);
				FProbeIndirectionDesc ProbeIndirection = GetProbeIndirection(NeighborProbeCoord, ClipmapIndex);
				bool bTwoSidedFoliage = GetScreenProbeIsTwoSidedFoliage(ScreenProbeAtlasCoord);

				//@todo - skip probes which are cached this frame
				if (ProbeIndirection.bValid)
				{
					uint SHBaseIndex = (ScreenProbeAtlasCoord.y * ScreenProbeAtlasViewSize.x + ScreenProbeAtlasCoord.x) * NUM_PDF_SH_COEFFICIENTS;
					uint ProbeSHBaseCoord = ProbeIndirection.ProbeIndex * NUM_RADIANCE_PROBE_PDF_COEFFICIENTS;

					for (uint CoefficientIndex = GroupThreadId.y; CoefficientIndex < NUM_RADIANCE_PROBE_PDF_COEFFICIENTS; CoefficientIndex += THREADGROUP_SIZE)
					{
						float Coefficient = 1.0f;
						float MaxValuePerThread = 1.0f;

						if (CoefficientIndex < NUM_PDF_SH_COEFFICIENTS)
						{
							// The Radiance Cache over-samples with high depth complexity caused by foliage, attempt to offset that by keeping at the lowest trace resolution
							Coefficient = bTwoSidedFoliage ? 0.0f : BRDFProbabilityDensityFunctionSH[SHBaseIndex + CoefficientIndex];
							MaxValuePerThread = (float)0xFFFFFFFF / 100000.0f;
						}
						
						int QuantizedCoefficient = Coefficient * MaxValuePerThread;
						InterlockedAdd(RWRadianceProbeSH_PDF[ProbeSHBaseCoord + CoefficientIndex], QuantizedCoefficient);
					}
				}
			}
		}
	}
}

#endif

RWBuffer<uint2> RWProbeTraceTileData;

#ifdef GenerateUniformProbeTraceTilesCS

Buffer<float4> ProbeTraceData;
int ForcedUniformLevel;

// Note: should match GetProbeTraceCost as closely as possible
[numthreads(THREADGROUP_SIZE, 1, 1)]
void GenerateUniformProbeTraceTilesCS(
	uint DispatchThreadId : SV_DispatchThreadID)
{
	uint ProbeTraceIndex = DispatchThreadId;

	if (ProbeTraceIndex < ProbeTraceAllocator[0])
	{
		FProbeTraceData TraceData = GetProbeTraceDataNoOffset(ProbeTraceData[ProbeTraceIndex]);

		float DistanceFromCameraSq = GetDistanceToCameraFromViewVectorSqr(PrimaryView.TranslatedWorldCameraOrigin - TraceData.ProbeTranslatedWorldCenter);

	#define DEBUG_UNIFORM_TRACES 0

		uint UniformLevel = DEBUG_UNIFORM_TRACES ? 1 : ForcedUniformLevel;

	#if !DEBUG_UNIFORM_TRACES
		if (DistanceFromCameraSq >= DownsampleDistanceFromCameraSq)
		{
			UniformLevel = 0;
		}
		else if (DistanceFromCameraSq < SupersampleDistanceFromCameraSq)
		{
			UniformLevel = 2;
		}

		if (TraceData.bForceDownsample)
		{
			UniformLevel = 0;
		}
	#endif
	
		uint TraceTileSize = 8;
		uint NumTraceTilesXY = (RadianceProbeResolution / TraceTileSize / 2) << UniformLevel;

		if (NumTraceTilesXY == 0)
		{
			NumTraceTilesXY = 1;
			UniformLevel = 1;
		}

		uint NumTraceTiles = NumTraceTilesXY * NumTraceTilesXY;
		uint GlobalTraceOffset;
		InterlockedAdd(RWProbeTraceTileAllocator[0], NumTraceTiles, GlobalTraceOffset);

		for (uint TraceTileIndex = 0; TraceTileIndex < NumTraceTiles; TraceTileIndex++)
		{
			uint2 TraceTileCoord = uint2(TraceTileIndex % NumTraceTilesXY, TraceTileIndex / NumTraceTilesXY);
			RWProbeTraceTileData[GlobalTraceOffset + TraceTileIndex] = PackTraceTileInfo(TraceTileCoord, UniformLevel, ProbeTraceIndex);
		}
	}
}

#endif

#ifdef GenerateAdaptiveProbeTraceTilesCS

bool ShouldRefineTraceTile(uint2 TraceTileCoord, uint NumTraceTilesXY, float LevelPDFThreshold, FThreeBandSHVector BRDF)
{
	float2 ProbeUV = (TraceTileCoord + float2(.5f, .5f)) / float(NumTraceTilesXY);
	float3 WorldConeDirection = EquiAreaSphericalMapping(ProbeUV);
	FThreeBandSHVector DirectionSH = SHBasisFunction3(WorldConeDirection);
	float PDF = max(DotSH3(BRDF, DirectionSH), 0);

	bool bRefineTraceTile = PDF > LevelPDFThreshold;
	return bRefineTraceTile;
}

Buffer<int> RadianceProbeSH_PDF;
float SupersampleTileBRDFThreshold;

RWTexture2D<float> RWDebugBRDFProbabilityDensityFunction;
uint DebugProbeBRDFOctahedronResolution;

groupshared uint SharedNumPendingTraceTiles;
groupshared uint2 PendingTraceTileList[THREADGROUP_SIZE * THREADGROUP_SIZE * 4];

groupshared uint SharedNumCompletedTraceTiles;
groupshared uint2 CompletedTraceTileList[THREADGROUP_SIZE * THREADGROUP_SIZE * 4];

groupshared uint GlobalTraceOffset;

FThreeBandSHVector GetBRDF_PDF(uint ProbeIndex)
{
	uint SHBaseIndex = ProbeIndex * NUM_RADIANCE_PROBE_PDF_COEFFICIENTS;
	float DequantizeScale = 100000.0f / (float)0xFFFFFFFF;

	float TotalWeight = RadianceProbeSH_PDF[SHBaseIndex + 9];
	float DecodeScale = 0.0f;

	if (TotalWeight > 0.0f)
	{
		DecodeScale = DequantizeScale / TotalWeight;
	}

	FThreeBandSHVector BRDF;
	BRDF.V0.x = RadianceProbeSH_PDF[SHBaseIndex + 0] * DecodeScale;
	BRDF.V0.y = RadianceProbeSH_PDF[SHBaseIndex + 1] * DecodeScale;
	BRDF.V0.z = RadianceProbeSH_PDF[SHBaseIndex + 2] * DecodeScale;
	BRDF.V0.w = RadianceProbeSH_PDF[SHBaseIndex + 3] * DecodeScale;
	BRDF.V1.x = RadianceProbeSH_PDF[SHBaseIndex + 4] * DecodeScale;
	BRDF.V1.y = RadianceProbeSH_PDF[SHBaseIndex + 5] * DecodeScale;
	BRDF.V1.z = RadianceProbeSH_PDF[SHBaseIndex + 6] * DecodeScale;
	BRDF.V1.w = RadianceProbeSH_PDF[SHBaseIndex + 7] * DecodeScale;
	BRDF.V2.x = RadianceProbeSH_PDF[SHBaseIndex + 8] * DecodeScale;
	return BRDF;
}

void SubdivideTraceTileTreeOneStep(
	uint ThreadIndex,
	uint BaseNumTraceTilesXY,
	uint Level,
	uint NumLevels,
	uint ProbeTraceIndex,
	FThreeBandSHVector BRDF,
	inout uint PendingTraceListStartIndex)
{
	uint NumTraceTilesXY = BaseNumTraceTilesXY << Level;
	uint NumPendingTraceTiles = SharedNumPendingTraceTiles;

	for (uint PendingTraceTileIndex = PendingTraceListStartIndex + ThreadIndex; PendingTraceTileIndex < NumPendingTraceTiles; PendingTraceTileIndex += THREADGROUP_SIZE * THREADGROUP_SIZE)
	{
		uint2 TraceTileCoord = UnpackTraceTileInfo(PendingTraceTileList[PendingTraceTileIndex]);

		if (Level < (NumLevels - 1) && ShouldRefineTraceTile(TraceTileCoord, NumTraceTilesXY, SupersampleTileBRDFThreshold, BRDF))
		{
			uint TileBaseIndex;
			InterlockedAdd(SharedNumPendingTraceTiles, 4, TileBaseIndex);
			PendingTraceTileList[TileBaseIndex + 0] = PackTraceTileInfo(TraceTileCoord * 2 + uint2(0, 0), Level + 1, ProbeTraceIndex);
			PendingTraceTileList[TileBaseIndex + 1] = PackTraceTileInfo(TraceTileCoord * 2 + uint2(1, 0), Level + 1, ProbeTraceIndex);
			PendingTraceTileList[TileBaseIndex + 2] = PackTraceTileInfo(TraceTileCoord * 2 + uint2(0, 1), Level + 1, ProbeTraceIndex);
			PendingTraceTileList[TileBaseIndex + 3] = PackTraceTileInfo(TraceTileCoord * 2 + uint2(1, 1), Level + 1, ProbeTraceIndex);
		}
		else
		{
			uint TileIndex;
			InterlockedAdd(SharedNumCompletedTraceTiles, 1, TileIndex);
			CompletedTraceTileList[TileIndex] = PackTraceTileInfo(TraceTileCoord, Level, ProbeTraceIndex);
		}
	}

	GroupMemoryBarrierWithGroupSync();

	PendingTraceListStartIndex = NumPendingTraceTiles;
}

void SubdivideTraceTileTree(
	uint ThreadIndex,
	uint BaseTraceTileResolution,
	uint NumLevels,
	uint ProbeTraceIndex,
	FThreeBandSHVector BRDF)
{
	uint PendingTraceListStartIndex = 0;

	// NumLevels must be a literal to allow the loop to unroll, otherwise we get this incorrect compile error from the DXC compiler:
	// error X3663: thread sync operation found in varying flow control, consider reformulating your algorithm so all threads will hit the sync simultaneously	
	// Manual unrolling to avoid error X3663 with FXC compiler on certain platforms preview
	if (NumLevels == 3)
	{
		SubdivideTraceTileTreeOneStep(ThreadIndex, BaseTraceTileResolution, 1, 3, ProbeTraceIndex, BRDF, PendingTraceListStartIndex);
		SubdivideTraceTileTreeOneStep(ThreadIndex, BaseTraceTileResolution, 2, 3, ProbeTraceIndex, BRDF, PendingTraceListStartIndex);
	}
	else if (NumLevels == 2)
	{
		SubdivideTraceTileTreeOneStep(ThreadIndex, BaseTraceTileResolution, 1, 2, ProbeTraceIndex, BRDF, PendingTraceListStartIndex);
	}
}

Buffer<float4> ProbeTraceData;

// Note: should match GetProbeTraceCost as closely as possible
[numthreads(THREADGROUP_SIZE, THREADGROUP_SIZE, 1)]
void GenerateAdaptiveProbeTraceTilesCS(
	uint3 GroupId : SV_GroupID,
	uint2 GroupThreadId : SV_GroupThreadID)
{
	uint ProbeTraceIndex = GroupId.z;

	FProbeTraceData TraceData = GetProbeTraceDataNoOffset(ProbeTraceData[ProbeTraceIndex]);

	float DistanceFromCameraSq = GetDistanceToCameraFromViewVectorSqr(PrimaryView.TranslatedWorldCameraOrigin - TraceData.ProbeTranslatedWorldCenter);

	// Ray gen pass:
	// 	Clear trace tile list
	// 	For each level [0 - 2] test PDF at tile center, issue trace tile if below threshold, otherwise subdivide and queue for next level
	// 	Write out all trace tiles for indirect dispatch

	if (all(GroupThreadId.xy == 0))
	{
		SharedNumCompletedTraceTiles = 0;
		SharedNumPendingTraceTiles = 0;
	}

	GroupMemoryBarrierWithGroupSync();

	uint NumLevels = 1;

	// Calculate subdivision level for the probe
	// Level 0 is half of RadianceProbeResolution
	if (DistanceFromCameraSq < DownsampleDistanceFromCameraSq)
	{
		NumLevels = DistanceFromCameraSq < SupersampleDistanceFromCameraSq ? 3 : 2;
	}

	if (TraceData.bForceDownsample)
	{
		NumLevels = 1;
	}

	FThreeBandSHVector BRDF = GetBRDF_PDF(TraceData.ProbeIndex);

	uint TraceTileSize = 8;
	uint NumTraceTilesXY = RadianceProbeResolution / TraceTileSize / 2;

	// Queue trace tiles for level 0
	if (all(GroupThreadId.xy < NumTraceTilesXY))
	{
		uint2 TraceTileCoord = GroupThreadId.xy;
		uint Level = 0;

		if (Level < (NumLevels - 1) && ShouldRefineTraceTile(TraceTileCoord, NumTraceTilesXY, 0.0f, BRDF))
		{
			uint TileBaseIndex;
			InterlockedAdd(SharedNumPendingTraceTiles, 4, TileBaseIndex);

			PendingTraceTileList[TileBaseIndex + 0] = PackTraceTileInfo(TraceTileCoord * 2 + uint2(0, 0), 1, ProbeTraceIndex);
			PendingTraceTileList[TileBaseIndex + 1] = PackTraceTileInfo(TraceTileCoord * 2 + uint2(1, 0), 1, ProbeTraceIndex);
			PendingTraceTileList[TileBaseIndex + 2] = PackTraceTileInfo(TraceTileCoord * 2 + uint2(0, 1), 1, ProbeTraceIndex);
			PendingTraceTileList[TileBaseIndex + 3] = PackTraceTileInfo(TraceTileCoord * 2 + uint2(1, 1), 1, ProbeTraceIndex);
		}
		else
		{
			uint TileIndex;
			InterlockedAdd(SharedNumCompletedTraceTiles, 1, TileIndex);
			CompletedTraceTileList[TileIndex] = PackTraceTileInfo(TraceTileCoord, 0, ProbeTraceIndex);
		}
	}

	GroupMemoryBarrierWithGroupSync();

	uint ThreadIndex = GroupThreadId.y * THREADGROUP_SIZE + GroupThreadId.x;

	// Queue trace tiles for remaining levels
	SubdivideTraceTileTree(ThreadIndex, NumTraceTilesXY, NumLevels, ProbeTraceIndex, BRDF);

	if (ThreadIndex == 0)
	{
		InterlockedAdd(RWProbeTraceTileAllocator[0], SharedNumCompletedTraceTiles, GlobalTraceOffset);
	}

	GroupMemoryBarrierWithGroupSync();

	for (uint TraceTileIndex = ThreadIndex; TraceTileIndex < SharedNumCompletedTraceTiles; TraceTileIndex += THREADGROUP_SIZE * THREADGROUP_SIZE)
	{
		RWProbeTraceTileData[GlobalTraceOffset + TraceTileIndex] = CompletedTraceTileList[TraceTileIndex];
	}
	

	// 'vis Lumen.RadianceCache.DebugBRDFProbabilityDensityFunction uv1'
	#define VISUALIZE_BRDF_PDF_SPHERICAL_HARMONIC 0
	#if VISUALIZE_BRDF_PDF_SPHERICAL_HARMONIC
		uint2 TexelCoord = GroupThreadId.xy;

		if (all(TexelCoord < DebugProbeBRDFOctahedronResolution))
		{
			float2 ProbeTexelCenter = float2(0.5, 0.5);
			float2 ProbeUV = (TexelCoord + ProbeTexelCenter) / (float)DebugProbeBRDFOctahedronResolution;
			float3 WorldConeDirection = EquiAreaSphericalMapping(ProbeUV);

			FThreeBandSHVector DirectionSH = SHBasisFunction3(WorldConeDirection);
			float PDF = max(DotSH3(BRDF, DirectionSH), 0) * .001f;

			uint2 ProbeAtlasBaseCoord = DebugProbeBRDFOctahedronResolution * uint2(ProbeIndex & ProbeAtlasResolutionModuloMask, ProbeIndex >> ProbeAtlasResolutionDivideShift);
			RWDebugBRDFProbabilityDensityFunction[ProbeAtlasBaseCoord + TexelCoord] = PDF;
		}
	#endif
}

#endif

#ifdef SetupTraceFromProbesCS

Buffer<uint> ProbeTraceTileAllocator;
RWBuffer<uint> RWTraceProbesIndirectArgs;
RWBuffer<uint> RWSortProbeTraceTilesIndirectArgs;
RWBuffer<uint> RWRadianceCacheHardwareRayTracingIndirectArgs;
RWBuffer<uint> RWHardwareRayTracingRayAllocatorBuffer;
uint SortTraceTilesGroupSize;

[numthreads(1, 1, 1)]
void SetupTraceFromProbesCS()
{
	uint NumProbeTraceTiles = ProbeTraceTileAllocator[0];

	// Decompose the dispatch group layout into 2d to work around hitting D3D11_CS_DISPATCH_MAX_THREAD_GROUPS_PER_DIMENSION (65k) with a 1d layout,
	// which manifests as flickering during Force Full Update

	WriteDispatchIndirectArgs(RWTraceProbesIndirectArgs, 0,
		TRACE_TILE_GROUP_STRIDE,
		(NumProbeTraceTiles + TRACE_TILE_GROUP_STRIDE - 1) / TRACE_TILE_GROUP_STRIDE,
		1);

	WriteDispatchIndirectArgs(RWSortProbeTraceTilesIndirectArgs, 0,
		(NumProbeTraceTiles + SortTraceTilesGroupSize - 1) / SortTraceTilesGroupSize,
		1,
		1);

	WriteDispatchIndirectArgs(RWRadianceCacheHardwareRayTracingIndirectArgs, 0,
		RADIANCE_CACHE_TRACE_TILE_SIZE_1D,
		NumProbeTraceTiles,
		1);

	RWHardwareRayTracingRayAllocatorBuffer[0] = NumProbeTraceTiles * RADIANCE_CACHE_TRACE_TILE_SIZE_1D;
}

#endif

#ifndef SORT_TILES_THREADGROUP_SIZE
#define SORT_TILES_THREADGROUP_SIZE 1
#endif

#define NUM_DIRECTION_BINS_2D 8
#define NUM_DIRECTION_BINS_1D (NUM_DIRECTION_BINS_2D * NUM_DIRECTION_BINS_2D)

#ifdef SortProbeTraceTilesCS

Buffer<uint> ProbeTraceTileAllocator;
Buffer<uint2> ProbeTraceTileData;

groupshared uint SharedNumTraceTileBins[NUM_DIRECTION_BINS_1D];
groupshared uint SharedTraceTileBinOffset[NUM_DIRECTION_BINS_1D];

[numthreads(SORT_TILES_THREADGROUP_SIZE, 1, 1)]
void SortProbeTraceTilesCS(
	uint GroupId : SV_GroupID,
	uint GroupThreadId : SV_GroupThreadID)
{
	// Clear bins to 0
	for (uint BinIndex = GroupThreadId; BinIndex < NUM_DIRECTION_BINS_1D; BinIndex += SORT_TILES_THREADGROUP_SIZE)
	{
		SharedNumTraceTileBins[BinIndex] = 0; 
		SharedTraceTileBinOffset[BinIndex] = 0;
	}

	GroupMemoryBarrierWithGroupSync();

	uint TraceTileIndex = GroupId * SORT_TILES_THREADGROUP_SIZE + GroupThreadId;

	// Count how many trace tiles in each direction bin
	if (TraceTileIndex < ProbeTraceTileAllocator[0])
	{
		uint2 TraceTileCoord;
		uint TraceTileLevel;
		uint ProbeTraceIndex;
		UnpackTraceTileInfo(ProbeTraceTileData[TraceTileIndex], TraceTileCoord, TraceTileLevel, ProbeTraceIndex);

		uint TraceResolution = (RadianceProbeResolution / 2) << TraceTileLevel;
		uint2 ProbeTexelCoord = TraceTileCoord * RADIANCE_CACHE_TRACE_TILE_SIZE_2D;
		uint2 DirectionalBin = ProbeTexelCoord * NUM_DIRECTION_BINS_2D / TraceResolution;

		//@todo - also bin by Morton encoded position
		uint FinalBinIndex = DirectionalBin.y * NUM_DIRECTION_BINS_2D + DirectionalBin.x;

		InterlockedAdd(SharedNumTraceTileBins[FinalBinIndex], 1);
	}

	GroupMemoryBarrierWithGroupSync();

	if (TraceTileIndex < ProbeTraceTileAllocator[0])
	{
		uint2 TraceTileData = ProbeTraceTileData[TraceTileIndex];

		uint2 TraceTileCoord;
		uint TraceTileLevel;
		uint ProbeTraceIndex;
		UnpackTraceTileInfo(TraceTileData, TraceTileCoord, TraceTileLevel, ProbeTraceIndex);

		uint TraceResolution = (RadianceProbeResolution / 2) << TraceTileLevel;
		uint2 ProbeTexelCoord = TraceTileCoord * RADIANCE_CACHE_TRACE_TILE_SIZE_2D;
		uint2 DirectionalBin = ProbeTexelCoord * NUM_DIRECTION_BINS_2D / TraceResolution;

		uint FinalBinIndex = DirectionalBin.y * NUM_DIRECTION_BINS_2D + DirectionalBin.x;

		uint SortedTraceTileOffset;

		// Calculate our sorted offset by adding up all the bins before us
		{
			InterlockedAdd(SharedTraceTileBinOffset[FinalBinIndex], 1, SortedTraceTileOffset);

			for (uint BinIndex = 0; BinIndex < FinalBinIndex; BinIndex++)
			{
				SortedTraceTileOffset += SharedNumTraceTileBins[BinIndex];
			}
		}

		// Write out to the sorted position
		RWProbeTraceTileData[GroupId * SORT_TILES_THREADGROUP_SIZE + SortedTraceTileOffset] = TraceTileData;
	}
}

#endif

float StepFactor;
float MinSampleRadius;
float MaxMeshSDFTraceDistance;
float CachedLightingPreExposure;

FConeTraceResult TraceForProbeTexel(FConeTraceInput TraceInput)
{
	FConeTraceResult TraceResult;
	TraceResult = (FConeTraceResult)0;
	TraceResult.Lighting = 0.0;
	TraceResult.Transparency = 1.0;
	TraceResult.OpaqueHitDistance = TraceInput.MaxTraceDistance;
	TraceInput.bZeroRadianceIfRayStartsInsideGeometry = true;

	ConeTraceLumenSceneVoxels(TraceInput, TraceResult);
	ApplySkylightToTraceResult(TraceInput.ConeDirection, TraceResult);

	if (CalculateIrradiance > 0)
	{
		TraceResult.Lighting += GetSkylightLeaking(TraceInput.ConeDirection, TraceResult.OpaqueHitDistance);
	}
	return TraceResult;
}

#ifdef TraceFromProbesCS

Buffer<float4> ProbeTraceData;
Buffer<uint2> ProbeTraceTileData;
Buffer<uint> ProbeTraceTileAllocator;

RWTexture2D<float3> RWRadianceProbeAtlasTexture;
#if RADIANCE_CACHE_SKY_VISIBILITY
	RWTexture2D<float> RWSkyVisibilityProbeAtlasTexture;
#endif
RWTexture2D<uint> RWDepthProbeAtlasTexture;

groupshared float3 SharedTraceRadiance[RADIANCE_CACHE_TRACE_TILE_SIZE_2D][RADIANCE_CACHE_TRACE_TILE_SIZE_2D];
groupshared float SharedTraceSkyVisibility[RADIANCE_CACHE_TRACE_TILE_SIZE_2D][RADIANCE_CACHE_TRACE_TILE_SIZE_2D];
groupshared float SharedTraceHitDistance[RADIANCE_CACHE_TRACE_TILE_SIZE_2D][RADIANCE_CACHE_TRACE_TILE_SIZE_2D];

[numthreads(RADIANCE_CACHE_TRACE_TILE_SIZE_2D, RADIANCE_CACHE_TRACE_TILE_SIZE_2D, 1)]
void TraceFromProbesCS(
	uint3 GroupId : SV_GroupID,
	uint2 GroupThreadId : SV_GroupThreadID)
{
	uint TraceTileIndex = GroupId.y * TRACE_TILE_GROUP_STRIDE + GroupId.x;

	if (TraceTileIndex < ProbeTraceTileAllocator[0])
	{
		uint2 TraceTileCoord;
		uint TraceTileLevel;
		uint ProbeTraceIndex;
		UnpackTraceTileInfo(ProbeTraceTileData[TraceTileIndex], TraceTileCoord, TraceTileLevel, ProbeTraceIndex);

		uint TraceResolution = (RadianceProbeResolution / 2) << TraceTileLevel;
		uint2 ProbeTexelCoord = TraceTileCoord * RADIANCE_CACHE_TRACE_TILE_SIZE_2D + GroupThreadId.xy;

	 	FProbeTraceData TraceData = GetProbeTraceDataNoOffset(ProbeTraceData[ProbeTraceIndex]);
		TraceData.ProbeTranslatedWorldCenter += ProbeWorldOffset[TraceData.ProbeIndex].xyz;

		if (all(ProbeTexelCoord < TraceResolution))
		{
			float2 ProbeTexelCenter = float2(0.5, 0.5);

			// No temporal accumulation, so just reads as dirty lighting
#define JITTER_TRACE_DIRECTION 0
#if JITTER_TRACE_DIRECTION
			uint2 RandomSeed = Rand3DPCG16(int3(floor(TraceData.ProbeTranslatedWorldCenter / GetRadianceProbeClipmapCellSize(0)))).xy;
			ProbeTexelCenter = Hammersley16(0, 1, RandomSeed);
#endif

			float2 ProbeUV = (ProbeTexelCoord + ProbeTexelCenter) / float(TraceResolution);
			float3 WorldConeDirection = EquiAreaSphericalMapping(ProbeUV);

			float FinalMinTraceDistance = GetRadianceProbeTMin(TraceData.ClipmapIndex);
			float FinalMaxTraceDistance = MaxTraceDistance;
			float EffectiveStepFactor = StepFactor;

			// Evenly distributing the sphere solid angle among all cones instead of based on Octahedron distortion
			float ConeHalfAngle = acosFast(1.0f - 1.0f / (float)(TraceResolution * TraceResolution));

			FConeTraceInput TraceInput;
			TraceInput.Setup(
				TraceData.ProbeTranslatedWorldCenter - DFHackToFloat(PrimaryView.PreViewTranslation),
				TraceData.ProbeTranslatedWorldCenter,
				WorldConeDirection,
				ConeHalfAngle,
				MinSampleRadius,
				FinalMinTraceDistance,
				FinalMaxTraceDistance,
				EffectiveStepFactor);

			// We want stable lighting when using radiance cache probes directly for lighting
			TraceInput.bDitheredTransparency = CalculateIrradiance > 0 ? 0 : 1;
			TraceInput.DitherScreenCoord = RadianceProbeResolution * uint2(TraceData.ProbeIndex & ProbeAtlasResolutionModuloMask, TraceData.ProbeIndex >> ProbeAtlasResolutionDivideShift) + ProbeTexelCoord;

			bool bContinueCardTracing = false;

			TraceInput.VoxelTraceStartDistance = CalculateVoxelTraceStartDistance(FinalMinTraceDistance, FinalMaxTraceDistance, MaxMeshSDFTraceDistance, bContinueCardTracing);

			FConeTraceResult TraceResult = TraceForProbeTexel(TraceInput);

			#define DEBUG_VISUALIZE_SAMPLING_RESOLUTION 0
			#if DEBUG_VISUALIZE_SAMPLING_RESOLUTION
				// Set r.Lumen.RadianceCache.SpatialFilterProbes 0 for raw output
				TraceResult.Lighting = TraceTileLevel == 0 ? float3(0, 1, 0) : (TraceTileLevel == 1 ? float3(1, 0, 0) : float3(1, 0, 1));
			#endif

			SharedTraceRadiance[GroupThreadId.y][GroupThreadId.x] = TraceResult.Lighting * CachedLightingPreExposure;
#if RADIANCE_CACHE_SKY_VISIBILITY
			SharedTraceSkyVisibility[GroupThreadId.y][GroupThreadId.x] = TraceResult.Transparency;
#endif
			SharedTraceHitDistance[GroupThreadId.y][GroupThreadId.x] = EncodeProbeDepth(InitProbeDepth(TraceResult.OpaqueHitDistance, TraceResult.Transparency < .5f, true, false));
		}

		GroupMemoryBarrierWithGroupSync();

		uint2 ProbeAtlasBaseCoord = RadianceProbeResolution * uint2(TraceData.ProbeIndex & ProbeAtlasResolutionModuloMask, TraceData.ProbeIndex >> ProbeAtlasResolutionDivideShift);

		if (TraceResolution < RadianceProbeResolution)
		{
			uint UpsampleFactor = RadianceProbeResolution / TraceResolution;
			ProbeAtlasBaseCoord += (RADIANCE_CACHE_TRACE_TILE_SIZE_2D * TraceTileCoord + GroupThreadId.xy) * UpsampleFactor;

			float3 Lighting = SharedTraceRadiance[GroupThreadId.y][GroupThreadId.x];
#if RADIANCE_CACHE_SKY_VISIBILITY
			float SkyVisibility = SharedTraceSkyVisibility[GroupThreadId.y][GroupThreadId.x];
#endif

			{
				for (uint Y = 0; Y < UpsampleFactor; Y++)
				{
					for (uint X = 0; X < UpsampleFactor; X++)
					{
						RWRadianceProbeAtlasTexture[ProbeAtlasBaseCoord + uint2(X, Y)] = Lighting;
#if RADIANCE_CACHE_SKY_VISIBILITY
						RWSkyVisibilityProbeAtlasTexture[ProbeAtlasBaseCoord + uint2(X, Y)] = SkyVisibility;
#endif
					}
				}
			}

			uint EncodedDepth = SharedTraceHitDistance[GroupThreadId.y][GroupThreadId.x];

			for (uint Y = 0; Y < UpsampleFactor; Y++)
			{
				for (uint X = 0; X < UpsampleFactor; X++)
				{
					RWDepthProbeAtlasTexture[ProbeAtlasBaseCoord + uint2(X, Y)] = EncodedDepth;
				}
			}
		}
		else
		{
			uint DownsampleFactor = TraceResolution / RadianceProbeResolution;
			uint WriteTileSize = RADIANCE_CACHE_TRACE_TILE_SIZE_2D / DownsampleFactor;

			if (all(GroupThreadId.xy < WriteTileSize))
			{
				float3 Lighting = 0;
				float SkyVisibility = 0.0f;

				{
					for (uint Y = 0; Y < DownsampleFactor; Y++)
					{
						for (uint X = 0; X < DownsampleFactor; X++)
						{
							Lighting += SharedTraceRadiance[GroupThreadId.y * DownsampleFactor + Y][GroupThreadId.x * DownsampleFactor + X];
#if RADIANCE_CACHE_SKY_VISIBILITY
							SkyVisibility += SharedTraceSkyVisibility[GroupThreadId.y * DownsampleFactor + Y][GroupThreadId.x * DownsampleFactor + X];
#endif
						}
					}
				}

				ProbeAtlasBaseCoord += WriteTileSize * TraceTileCoord + GroupThreadId.xy;
				RWRadianceProbeAtlasTexture[ProbeAtlasBaseCoord] = Lighting / (float)(DownsampleFactor * DownsampleFactor);
#if RADIANCE_CACHE_SKY_VISIBILITY
				RWSkyVisibilityProbeAtlasTexture[ProbeAtlasBaseCoord] = SkyVisibility / (float)(DownsampleFactor * DownsampleFactor);
#endif
				FProbeDepth ProbeDepth;
				ProbeDepth.HitDistance = MaxHalfFloat;
				ProbeDepth.bHit = false;
				ProbeDepth.bFrontface = false;
				ProbeDepth.bTwoSided = false;

				for (uint Y = 0; Y < DownsampleFactor; Y++)
				{
					for (uint X = 0; X < DownsampleFactor; X++)
					{
						FProbeDepth OtherProbeDepth = DecodeProbeDepth(SharedTraceHitDistance[GroupThreadId.y * DownsampleFactor + Y][GroupThreadId.x * DownsampleFactor + X]);
						ProbeDepth.HitDistance = min(ProbeDepth.HitDistance, OtherProbeDepth.HitDistance);
						ProbeDepth.bHit = ProbeDepth.bHit || OtherProbeDepth.bHit;
						ProbeDepth.bFrontface = ProbeDepth.bFrontface || OtherProbeDepth.bFrontface;
						ProbeDepth.bTwoSided = ProbeDepth.bTwoSided || OtherProbeDepth.bTwoSided;
					}
				}

				RWDepthProbeAtlasTexture[ProbeAtlasBaseCoord] = EncodeProbeDepth(ProbeDepth);
			}
		}
	}
}

#endif

Texture2D<float3> RadianceProbeAtlasTexture;
Texture2D<float> SkyVisibilityProbeAtlasTexture;
Texture2D<uint> DepthProbeAtlasTexture;

#ifdef FilterProbeRadianceWithGatherCS

RWTexture2D<float3> RWRadianceProbeAtlasTexture;
#if RADIANCE_CACHE_SKY_VISIBILITY
	RWTexture2D<float> RWSkyVisibilityProbeAtlasTexture;
#endif
Buffer<float4> ProbeTraceData;
float SpatialFilterMaxRadianceHitAngle;

[numthreads(THREADGROUP_SIZE, THREADGROUP_SIZE, 1)]
void FilterProbeRadianceWithGatherCS(
	uint3 GroupId : SV_GroupID,
	uint3 GroupThreadId : SV_GroupThreadID,
	uint3 DispatchThreadId : SV_DispatchThreadID)
{
	uint ProbeTraceIndex = GroupId.z;
	uint2 ProbeTexelCoord = DispatchThreadId.xy;
	
	if (all(ProbeTexelCoord < RadianceProbeResolution))
	{
		FProbeTraceData TraceData = GetProbeTraceDataNoOffset(ProbeTraceData[ProbeTraceIndex]);

		uint2 ProbeAtlasBaseCoord = RadianceProbeResolution * uint2(TraceData.ProbeIndex & ProbeAtlasResolutionModuloMask, TraceData.ProbeIndex >> ProbeAtlasResolutionDivideShift);
		float3 Lighting = RadianceProbeAtlasTexture[ProbeTexelCoord + ProbeAtlasBaseCoord].xyz;
#if RADIANCE_CACHE_SKY_VISIBILITY
		float SkyVisibility = SkyVisibilityProbeAtlasTexture[ProbeTexelCoord + ProbeAtlasBaseCoord].x;
#endif
		float HitDistance = DecodeProbeDepth(DepthProbeAtlasTexture[ProbeTexelCoord + ProbeAtlasBaseCoord]).HitDistance;
		float TotalWeight = 1.0f;

		float2 ProbeTexelCenter = float2(0.5, 0.5);
		float2 ProbeUV = (ProbeTexelCoord + ProbeTexelCenter) / (float)RadianceProbeResolution;
		float3 WorldConeDirection = EquiAreaSphericalMapping(ProbeUV);
		float ProbeCellSizeForOcclusionTest = GetRadianceProbeTMin(TraceData.ClipmapIndex) == 0.0f ? GetRadianceProbeClipmapCellSize(TraceData.ClipmapIndex) : GetRadianceProbeTMin(TraceData.ClipmapIndex);
		int3 ProbeCoord = GetRadianceProbeCoord(TraceData.ProbeTranslatedWorldCenter, TraceData.ClipmapIndex);
			
		TraceData.ProbeTranslatedWorldCenter += ProbeWorldOffset[TraceData.ProbeIndex].xyz;

		int3 Offsets[6];
		Offsets[0] = int3(-1, 0, 0);
		Offsets[1] = int3(1, 0, 0);
		Offsets[2] = int3(0, -1, 0);
		Offsets[3] = int3(0, 1, 0);
		Offsets[4] = int3(0, 0, -1);
		Offsets[5] = int3(0, 0, 1);

		for (uint OffsetIndex = 0; OffsetIndex < 6; OffsetIndex++)
		{
			int3 NeighborCoord = ProbeCoord + Offsets[OffsetIndex];

			if (all(NeighborCoord >= 0) && all(NeighborCoord < (int3)RadianceProbeClipmapResolution))
			{
				FProbeIndirectionDesc NeighborProbeIndirection = GetProbeIndirection(NeighborCoord, TraceData.ClipmapIndex);

				if (NeighborProbeIndirection.bValid)
				{
					uint2 NeighborProbeAtlasBaseCoord = RadianceProbeResolution * uint2(NeighborProbeIndirection.ProbeIndex & ProbeAtlasResolutionModuloMask, NeighborProbeIndirection.ProbeIndex >> ProbeAtlasResolutionDivideShift);
					FProbeDepth NeighborProbeDepth = DecodeProbeDepth(DepthProbeAtlasTexture[ProbeTexelCoord + NeighborProbeAtlasBaseCoord]);
					float3 NeighborTranslatedWorldPosition = GetProbeTranslatedWorldPosition(NeighborCoord, TraceData.ClipmapIndex, NeighborProbeIndirection.ProbeIndex);

					float OcclusionWeight = NeighborProbeDepth.bFrontface || NeighborProbeDepth.bTwoSided ? 1.0f : 0.0f;
			
					// Test whether probe can see neighbor probe's ray starting point and if occluded then discard the neighbor radiance to reduce leaking.
					// Need to offset starting point as all probe traces start after GetRadianceProbeTMin and there's no depth information in the region where probe TMin spheres intersect.
					// That offset can't be also too large due to limited probe angular resolution making it pretty inaccurate at connecting paths at larger distances.
					// Also run this test in reverse by checking whether neighbor probe can see probe's ray starting point, which improves chances of finding a thin wall between two probes.
					float OcclusionTestOffset = 2.0f * ProbeCellSizeForOcclusionTest;

					// Probe to NeighborProbe's ray
					{
						float3 NeighborOcclusionTestPosition = NeighborTranslatedWorldPosition + OcclusionTestOffset * WorldConeDirection;
						float3 ToNeighborOcclusionPosition = NeighborOcclusionTestPosition - TraceData.ProbeTranslatedWorldCenter;
						uint2 ProbeTexelCoordForNeighborOcclusionPosition = InverseEquiAreaSphericalMapping(ToNeighborOcclusionPosition) * RadianceProbeResolution;
						float ProbeDepthForNeighborOcclusionPosition = DecodeProbeDepth(DepthProbeAtlasTexture[ProbeTexelCoordForNeighborOcclusionPosition + ProbeAtlasBaseCoord]).HitDistance;

						if (ProbeDepthForNeighborOcclusionPosition * ProbeDepthForNeighborOcclusionPosition < dot(ToNeighborOcclusionPosition, ToNeighborOcclusionPosition))
						{
							OcclusionWeight = 0.0f;
						}
					}

					// NeighborProbe to Probe's ray
					{
						float3 OcclusionTestPosition = TraceData.ProbeTranslatedWorldCenter + OcclusionTestOffset * WorldConeDirection;
						float3 ToOcclusionPosition = OcclusionTestPosition - NeighborTranslatedWorldPosition;
						uint2 NeighborProbeTexelCoordForOcclusionPosition = InverseEquiAreaSphericalMapping(ToOcclusionPosition) * RadianceProbeResolution;
						float NeighborProbeDepthForNeighborOcclusionPosition = DecodeProbeDepth(DepthProbeAtlasTexture[NeighborProbeTexelCoordForOcclusionPosition + NeighborProbeAtlasBaseCoord]).HitDistance;

						if (NeighborProbeDepthForNeighborOcclusionPosition * NeighborProbeDepthForNeighborOcclusionPosition < dot(ToOcclusionPosition, ToOcclusionPosition))
						{
							OcclusionWeight = 0.0f;
						}
					}

					// Clamp neighbor's hit distance to our own.  This helps preserve contact shadows, as a long neighbor hit distance will cause a small NeighborAngle and bias toward distant lighting.
					if (NeighborProbeDepth.bHit)
					{
						NeighborProbeDepth.HitDistance = min(NeighborProbeDepth.HitDistance, HitDistance);
					}

					float3 NeighborHitPosition = NeighborTranslatedWorldPosition + WorldConeDirection * NeighborProbeDepth.HitDistance;
					float3 ToNeighborHit = NeighborHitPosition - TraceData.ProbeTranslatedWorldCenter;
					float NeighborAngle = acosFast(dot(ToNeighborHit, WorldConeDirection) / length(ToNeighborHit));
					float AngleWeight = 1.0f - saturate(NeighborAngle / SpatialFilterMaxRadianceHitAngle);

					float Weight = AngleWeight * OcclusionWeight;
					Lighting += RadianceProbeAtlasTexture[ProbeTexelCoord + NeighborProbeAtlasBaseCoord].xyz * Weight;
#if RADIANCE_CACHE_SKY_VISIBILITY
					SkyVisibility += SkyVisibilityProbeAtlasTexture[ProbeTexelCoord + NeighborProbeAtlasBaseCoord].x * Weight;
#endif
					TotalWeight += Weight;
				}
			}
		}

		RWRadianceProbeAtlasTexture[ProbeTexelCoord + ProbeAtlasBaseCoord] = Lighting / TotalWeight;
#if RADIANCE_CACHE_SKY_VISIBILITY
		RWSkyVisibilityProbeAtlasTexture[ProbeTexelCoord + ProbeAtlasBaseCoord] = SkyVisibility / TotalWeight;
#endif
	}
}

#endif

#ifdef CalculateProbeIrradianceCS

RWTexture2D<float3> RWFinalIrradianceAtlas;
Buffer<float4> ProbeTraceData;

#define DOWNSAMPLED_RADIANCE_SIZE 8
groupshared float3 SharedDownsampledProbeRadiance[DOWNSAMPLED_RADIANCE_SIZE][DOWNSAMPLED_RADIANCE_SIZE];

[numthreads(THREADGROUP_SIZE, THREADGROUP_SIZE, 1)]
void CalculateProbeIrradianceCS(
	uint3 GroupId : SV_GroupID,
	uint3 DispatchThreadId : SV_DispatchThreadID,
	uint3 GroupThreadId : SV_GroupThreadID)
{
	uint ProbeTraceIndex = GroupId.z;

	FProbeTraceData TraceData = GetProbeTraceDataNoOffset(ProbeTraceData[ProbeTraceIndex]);

	uint DownsampleFactor = RadianceProbeResolution / DOWNSAMPLED_RADIANCE_SIZE;
	uint2 AtlasBaseCoord = RadianceProbeResolution * uint2(TraceData.ProbeIndex & ProbeAtlasResolutionModuloMask, TraceData.ProbeIndex >> ProbeAtlasResolutionDivideShift);
	float InvDownsampleFactorSqr = 1.0f / (DownsampleFactor * DownsampleFactor);

#define DOWNSAMPLE_TO_SHARED_MEMORY 1
#if DOWNSAMPLE_TO_SHARED_MEMORY
	{
		for (uint DestY = GroupThreadId.y; DestY < DOWNSAMPLED_RADIANCE_SIZE; DestY += THREADGROUP_SIZE)
		{
			for (uint DestX = GroupThreadId.x; DestX < DOWNSAMPLED_RADIANCE_SIZE; DestX += THREADGROUP_SIZE)
			{
				float3 Radiance = 0;

				for (uint YOffset = 0; YOffset < DownsampleFactor; YOffset++)
				{
					for (uint XOffset = 0; XOffset < DownsampleFactor; XOffset++)
					{
						uint2 SourceTexelCoord = uint2(DestX * DownsampleFactor + XOffset, DestY * DownsampleFactor + YOffset);
						Radiance += RadianceProbeAtlasTexture.Load(uint3(AtlasBaseCoord + SourceTexelCoord, 0)).xyz;
					}
				}

				SharedDownsampledProbeRadiance[DestY][DestX] = Radiance * InvDownsampleFactorSqr;
			}
		}
	}

	GroupMemoryBarrierWithGroupSync();
#endif

	uint IrradianceBorderSize = 1;
	uint OutputIrradianceProbeResolution = IrradianceProbeResolution + 2 * IrradianceBorderSize;

	for (uint DestY = GroupThreadId.y; DestY < OutputIrradianceProbeResolution; DestY += THREADGROUP_SIZE)
	{
		for (uint DestX = GroupThreadId.x; DestX < OutputIrradianceProbeResolution; DestX += THREADGROUP_SIZE)
		{
			uint2 IrradianceProbeTexelCoord = OctahedralMapWrapBorder(uint2(DestX, DestY), OutputIrradianceProbeResolution, IrradianceBorderSize);
			float2 IrradianceProbeUV = (IrradianceProbeTexelCoord + float2(0.5f, 0.5f)) / (float)IrradianceProbeResolution;
			float3 IrradianceDirection = EquiAreaSphericalMapping(IrradianceProbeUV);
			float3 Irradiance = 0;
			float TotalWeight = 0;

			uint SourceProbeResolution = DOWNSAMPLE_TO_SHARED_MEMORY ? DOWNSAMPLED_RADIANCE_SIZE : RadianceProbeResolution;

			for (uint Y = 0; Y < SourceProbeResolution; Y++)
			{
				for (uint X = 0; X < SourceProbeResolution; X++)
				{
					float2 RadianceProbeUV = (float2(X, Y) + float2(0.5, 0.5)) / (float)SourceProbeResolution;
					float3 RadianceDirection = EquiAreaSphericalMapping(RadianceProbeUV);

					float NdotL = dot(IrradianceDirection, RadianceDirection);

					if (NdotL > 0)
					{
						float SampleWeight = NdotL;
						#if DOWNSAMPLE_TO_SHARED_MEMORY
							float3 Radiance = SharedDownsampledProbeRadiance[Y][X];
						#else
							float3 Radiance = RadianceProbeAtlasTexture.Load(uint3(AtlasBaseCoord + uint2(X, Y), 0)).xyz;
						#endif
						
						Irradiance += Radiance * SampleWeight;
						TotalWeight += SampleWeight;
					}
				}
			}

			Irradiance *= 1.0f / TotalWeight;

			uint2 IrradianceAtlasCoord = uint2(DestX, DestY) + OutputIrradianceProbeResolution * uint2(TraceData.ProbeIndex & ProbeAtlasResolutionModuloMask, TraceData.ProbeIndex >> ProbeAtlasResolutionDivideShift);

			RWFinalIrradianceAtlas[IrradianceAtlasCoord] = Irradiance;
		}
	}
}

#endif

#ifdef PrepareProbeOcclusionCS

RWTexture2D<float2> RWProbeOcclusionAtlas;
RWBuffer<uint> RWProbeValid;
Buffer<float4> ProbeTraceData;
float OcclusionKernelCosineExponent;

#if PROBE_OCCLUSION_HWRT
groupshared uint SharedNumBackfaces;
groupshared uint SharedClosestFrontfaceDistance;
#endif

[numthreads(THREADGROUP_SIZE, THREADGROUP_SIZE, 1)]
void PrepareProbeOcclusionCS(
	uint3 GroupId : SV_GroupID,
	uint3 GroupThreadId : SV_GroupThreadID)
{
	uint ProbeTraceIndex = GroupId.z;
	FProbeTraceData ProbeData = GetProbeTraceDataNoOffset(ProbeTraceData[ProbeTraceIndex]);
	uint ProbeIndex = ProbeData.ProbeIndex;
	uint2 AtlasBaseCoord = uint2(ProbeIndex & ProbeAtlasResolutionModuloMask, ProbeIndex >> ProbeAtlasResolutionDivideShift);

	uint OcclusionBorderSize = 1;

#if PROBE_OCCLUSION_HWRT
	if (all(GroupThreadId.xy == 0))
	{
		SharedNumBackfaces = 0;
		SharedClosestFrontfaceDistance = 100000;
	}

	GroupMemoryBarrierWithGroupSync();
#endif

	uint2 FinalOcclusionTexelCoord;

	for (FinalOcclusionTexelCoord.y = GroupThreadId.y; FinalOcclusionTexelCoord.y < FinalOcclusionProbeResolution; FinalOcclusionTexelCoord.y += THREADGROUP_SIZE)
	{
		for (FinalOcclusionTexelCoord.x = GroupThreadId.x; FinalOcclusionTexelCoord.x < FinalOcclusionProbeResolution; FinalOcclusionTexelCoord.x += THREADGROUP_SIZE)
		{
#define FILTER_PROBE_OCCLUSION 0
#if FILTER_PROBE_OCCLUSION
			uint2 DestProbeTexelCoord = OctahedralMapWrapBorder(FinalOcclusionTexelCoord, FinalOcclusionProbeResolution, OcclusionBorderSize);
			float2 DestProbeUV = (DestProbeTexelCoord + float2(0.5f, 0.5f)) / (float)OcclusionProbeResolution;
			float3 DestDirection = EquiAreaSphericalMapping(DestProbeUV);

			float AccumulatedDepth = 0;
			float AccumulatedDepthSq = 0;
			float TotalWeight = 0;

			for (uint Y = 0; Y < RadianceProbeResolution; Y++)
			{
				for (uint X = 0; X < RadianceProbeResolution; X++)
				{
					float2 SourceProbeUV = (float2(X, Y) + float2(0.5f, 0.5f)) / (float)RadianceProbeResolution;
					float3 SourceDirection = EquiAreaSphericalMapping(SourceProbeUV);

					float SampleWeight = pow(max(dot(SourceDirection, DestDirection), 0.0f), OcclusionKernelCosineExponent);

					if (SampleWeight > .001f)
					{
						FProbeDepth ProbeDepth = DecodeProbeDepth(DepthProbeAtlasTexture.Load(uint3(AtlasBaseCoord * RadianceProbeResolution + uint2(X, Y), 0)));
						bool bReduceOcclusion = ProbeDepth.bTwoSided;
						ProbeDepth.HitDistance *= bReduceOcclusion ? 4.0f : 1.0f;

						AccumulatedDepth += ProbeDepth.HitDistance * SampleWeight;
						AccumulatedDepthSq += ProbeDepth.HitDistance * ProbeDepth.HitDistance * SampleWeight;
						TotalWeight += SampleWeight;
					}
				}
			}

			if (TotalWeight > 0.0f)
			{
				AccumulatedDepth /= TotalWeight;
				AccumulatedDepthSq /= TotalWeight;
			}

#else
			uint2 ProbeDepthTexelCoord = OctahedralMapWrapBorder(FinalOcclusionTexelCoord, FinalOcclusionProbeResolution, OcclusionBorderSize);

			float AccumulatedDepth = 0;
			float AccumulatedDepthSq = 0;
			uint NumBackfaces = 0;
			uint ClosestFrontfaceDistance = 100000;

			uint2 AtlasCoord = ProbeDepthTexelCoord + AtlasBaseCoord * RadianceProbeResolution;
				
			FProbeDepth ProbeDepth = DecodeProbeDepth(DepthProbeAtlasTexture.Load(uint3(AtlasCoord, 0)));
			bool bReduceOcclusion = ProbeDepth.bTwoSided;
			ProbeDepth.HitDistance *= bReduceOcclusion ? 4.0f : 1.0f;
			bool bBackface = !ProbeDepth.bFrontface && !ProbeDepth.bTwoSided;

			NumBackfaces += bBackface ? 1 : 0;

			if (!bBackface)
			{
				ClosestFrontfaceDistance = min(ClosestFrontfaceDistance, ProbeDepth.HitDistance);
			}

			AccumulatedDepth += ProbeDepth.HitDistance;
			AccumulatedDepthSq += ProbeDepth.HitDistance * ProbeDepth.HitDistance;

			#if PROBE_OCCLUSION_HWRT
				if (NumBackfaces > 0)
				{
					InterlockedAdd(SharedNumBackfaces, NumBackfaces); 
				}

				InterlockedMin(SharedClosestFrontfaceDistance, ClosestFrontfaceDistance);
			#endif

			if (RadianceProbeResolution != OcclusionProbeResolution)
			{
				// Visual assert
				AccumulatedDepth = 0;
			}
#endif
			uint2 FinalAtlasCoord = FinalOcclusionTexelCoord + FinalOcclusionProbeResolution * AtlasBaseCoord;
			RWProbeOcclusionAtlas[FinalAtlasCoord] = float2(AccumulatedDepth, AccumulatedDepthSq);
		}
	}

	GroupMemoryBarrierWithGroupSync();

	if (all(GroupThreadId.xy == 0))
	{
		#if PROBE_OCCLUSION_HWRT
			uint Valid = (SharedNumBackfaces < .1f * RadianceProbeResolution * RadianceProbeResolution
				&& SharedClosestFrontfaceDistance > .01f * GetRadianceProbeClipmapCellSize(ProbeData.ClipmapIndex)) ? 1 : 0;
		#else
			// SWRT does not have access to bBackface, probes are invalid if they are inside the Global SDF
			ProbeData.ProbeTranslatedWorldCenter += ProbeWorldOffset[ProbeData.ProbeIndex].xyz;
			float DistanceToSurface = GetDistanceToNearestSurfaceGlobal(ProbeData.ProbeTranslatedWorldCenter);

			float SampledClipmapVoxelExtent = 0.0f;

			for (uint ClipmapIndex = 0; ClipmapIndex < NumGlobalSDFClipmaps; ClipmapIndex++)
			{
				float DistanceFromClipmap = ComputeDistanceFromBoxToPointInside(GlobalVolumeTranslatedCenterAndExtent[ClipmapIndex].xyz, GlobalVolumeTranslatedCenterAndExtent[ClipmapIndex].www, ProbeData.ProbeTranslatedWorldCenter);
				const float ClipmapVoxelExtent = GlobalVolumeTranslatedCenterAndExtent[ClipmapIndex].w * GlobalVolumeTexelSize;

				if (DistanceFromClipmap > ClipmapVoxelExtent)
				{
					SampledClipmapVoxelExtent = ClipmapVoxelExtent;
					break;
				}
			}
	
			uint Valid = DistanceToSurface > SampledClipmapVoxelExtent * .5f * CoveredExpandSurfaceScale ? 1 : 0;
		#endif
		RWProbeValid[ProbeIndex] = Valid;
	}
}

#endif

#ifdef FixupBordersAndGenerateMipsCS

RWTexture2D<float3> RWFinalRadianceAtlasMip0;
RWTexture2D<float3> RWFinalRadianceAtlasMip1;
RWTexture2D<float3> RWFinalRadianceAtlasMip2;
#if RADIANCE_CACHE_SKY_VISIBILITY
	RWTexture2D<float> RWFinalSkyVisibilityAtlasMip0;
#endif
Buffer<float4> ProbeTraceData;

#if GENERATE_MIPS
	groupshared float3 SharedLightingMip0[THREADGROUP_SIZE][THREADGROUP_SIZE];
	groupshared float3 SharedLightingMip1[THREADGROUP_SIZE / 2][THREADGROUP_SIZE / 2];
#endif

#if GENERATE_MIPS && THREADGROUP_SIZE != 8
	#error THREADGROUP_SIZE wrong size
#endif

[numthreads(THREADGROUP_SIZE, THREADGROUP_SIZE, 1)]
void FixupBordersAndGenerateMipsCS(
	uint3 GroupId : SV_GroupID,
	uint3 DispatchThreadId : SV_DispatchThreadID,
	uint3 GroupThreadId : SV_GroupThreadID)
{
	uint ProbeTraceIndex = DispatchThreadId.z;
	uint ProbeIndex = GetProbeIndexFromProbeTraceData(ProbeTraceData[ProbeTraceIndex]);
	uint2 ProbeCoord = uint2(ProbeIndex & ProbeAtlasResolutionModuloMask, ProbeIndex >> ProbeAtlasResolutionDivideShift);

	uint2 FinalProbeTexelCoord = DispatchThreadId.xy;

	if (all(FinalProbeTexelCoord < FinalProbeResolution))
	{
		uint2 ProbeTexelCoord = OctahedralMapWrapBorder(FinalProbeTexelCoord, FinalProbeResolution, 1u << FinalRadianceAtlasMaxMip);
		uint2 AtlasCoord = ProbeTexelCoord + RadianceProbeResolution * uint2(ProbeIndex & ProbeAtlasResolutionModuloMask, ProbeIndex >> ProbeAtlasResolutionDivideShift);

		uint2 FinalAtlasCoord = FinalProbeTexelCoord + FinalProbeResolution * ProbeCoord;

		float3 Lighting = RadianceProbeAtlasTexture.Load(uint3(AtlasCoord, 0)).xyz;
		RWFinalRadianceAtlasMip0[FinalAtlasCoord] = Lighting;

#if RADIANCE_CACHE_SKY_VISIBILITY
		float SkyVisibility = SkyVisibilityProbeAtlasTexture.Load(uint3(AtlasCoord, 0)).x;
		RWFinalSkyVisibilityAtlasMip0[FinalAtlasCoord] = SkyVisibility;
#endif

#if GENERATE_MIPS
		SharedLightingMip0[GroupThreadId.y][GroupThreadId.x] = Lighting;
#endif
	}

#if GENERATE_MIPS
	if (FinalRadianceAtlasMaxMip > 0)
	{
		GroupMemoryBarrierWithGroupSync();

		uint MipLevel = 1;
		uint ParentMipSize = FinalProbeResolution >> (MipLevel - 1);
		uint MipSize = FinalProbeResolution >> MipLevel;
		uint ThreadgroupSizeForMip = (uint)THREADGROUP_SIZE >> MipLevel;
		uint2 MipProbeTexelCoord = GroupThreadId.xy + ThreadgroupSizeForMip * GroupId.xy;

		if (all(and(GroupThreadId.xy < ThreadgroupSizeForMip, MipProbeTexelCoord < MipSize)))
		{
			uint2 ParentProbeTexelCoordBase = MipProbeTexelCoord * 2;
			float InvParentMipSize = 1.0f / ParentMipSize;
			float2 ProbeUV00 = (ParentProbeTexelCoordBase + float2(0, 0) + float2(.5f, .5f)) * InvParentMipSize;
			float2 ProbeUV10 = (ParentProbeTexelCoordBase + float2(1, 0) + float2(.5f, .5f)) * InvParentMipSize;
			float2 ProbeUV01 = (ParentProbeTexelCoordBase + float2(0, 1) + float2(.5f, .5f)) * InvParentMipSize;
			float2 ProbeUV11 = (ParentProbeTexelCoordBase + float2(1, 1) + float2(.5f, .5f)) * InvParentMipSize;

			float3 Lighting = 0;
			Lighting += SharedLightingMip0[GroupThreadId.y * 2 + 0][GroupThreadId.x * 2 + 0];
			Lighting += SharedLightingMip0[GroupThreadId.y * 2 + 0][GroupThreadId.x * 2 + 1];
			Lighting += SharedLightingMip0[GroupThreadId.y * 2 + 1][GroupThreadId.x * 2 + 0];
			Lighting += SharedLightingMip0[GroupThreadId.y * 2 + 1][GroupThreadId.x * 2 + 1];

			Lighting /= 4;

			SharedLightingMip1[GroupThreadId.y][GroupThreadId.x] = Lighting;
			uint2 FinalAtlasCoord = MipProbeTexelCoord + MipSize * ProbeCoord;
			RWFinalRadianceAtlasMip1[FinalAtlasCoord] = Lighting;
		}
	}

	if (FinalRadianceAtlasMaxMip > 1)
	{
		GroupMemoryBarrierWithGroupSync();

		uint MipLevel = 2;
		uint ParentMipSize = FinalProbeResolution >> (MipLevel - 1);
		uint MipSize = FinalProbeResolution >> MipLevel;
		uint ThreadgroupSizeForMip = (uint)THREADGROUP_SIZE >> MipLevel;
		uint2 MipProbeTexelCoord = GroupThreadId.xy + ThreadgroupSizeForMip * GroupId.xy;

		if (all(and(GroupThreadId.xy < ThreadgroupSizeForMip, MipProbeTexelCoord < MipSize)))
		{
			uint2 ParentProbeTexelCoordBase = MipProbeTexelCoord * 2;
			float InvParentMipSize = 1.0f / ParentMipSize;
			float2 ProbeUV00 = (ParentProbeTexelCoordBase + float2(0, 0) + float2(.5f, .5f)) * InvParentMipSize;
			float2 ProbeUV10 = (ParentProbeTexelCoordBase + float2(1, 0) + float2(.5f, .5f)) * InvParentMipSize;
			float2 ProbeUV01 = (ParentProbeTexelCoordBase + float2(0, 1) + float2(.5f, .5f)) * InvParentMipSize;
			float2 ProbeUV11 = (ParentProbeTexelCoordBase + float2(1, 1) + float2(.5f, .5f)) * InvParentMipSize;

			float3 Lighting = 0;
			Lighting += SharedLightingMip1[GroupThreadId.y * 2 + 0][GroupThreadId.x * 2 + 0];
			Lighting += SharedLightingMip1[GroupThreadId.y * 2 + 0][GroupThreadId.x * 2 + 1];
			Lighting += SharedLightingMip1[GroupThreadId.y * 2 + 1][GroupThreadId.x * 2 + 0];
			Lighting += SharedLightingMip1[GroupThreadId.y * 2 + 1][GroupThreadId.x * 2 + 1];

			uint2 FinalAtlasCoord = MipProbeTexelCoord + MipSize * ProbeCoord;
			RWFinalRadianceAtlasMip2[FinalAtlasCoord] = Lighting / 4;
		}
	}
#endif
}

#endif


#ifdef BlendProbeOutputsCS

RWTexture2D<float3> RWBlendedIrradianceAtlas;
RWTexture2D<float2> RWBlendedOcclusionAtlas;
RWBuffer<float4> RWBlendedProbeWorldOffset;
Texture2D<float3> FinalIrradianceAtlas;
Texture2D<float2> ProbeOcclusionAtlas;
Buffer<uint> ProbeCreatedFrame;
Buffer<uint> ProbeAllocator;
float BlendSpeed;
uint FrameNumber;

[numthreads(THREADGROUP_SIZE, THREADGROUP_SIZE, 1)]
void BlendProbeOutputsCS(
	uint3 GroupId : SV_GroupID,
	uint3 GroupThreadId : SV_GroupThreadID)
{
	uint ProbeIndex = GroupId.z;

	if (ProbeIndex < ProbeAllocator[0] && ProbeCreatedFrame[ProbeIndex] != 0)
	{
		float HistoryValid = RWBlendedProbeWorldOffset[ProbeIndex].w;
		float LocalBlendSpeed = HistoryValid > 0.0f ? BlendSpeed : 1.0f;
		uint2 ProbeCoord = uint2(ProbeIndex & ProbeAtlasResolutionModuloMask, ProbeIndex >> ProbeAtlasResolutionDivideShift);

		uint IrradianceBorderSize = 1;
		uint OutputIrradianceProbeResolution = IrradianceProbeResolution + 2 * IrradianceBorderSize;
		uint2 IrradianceBaseCoord = OutputIrradianceProbeResolution * ProbeCoord;
		
		uint2 ProbeTexelCoord;

		for (ProbeTexelCoord.y = GroupThreadId.y; ProbeTexelCoord.y < OutputIrradianceProbeResolution; ProbeTexelCoord.y += THREADGROUP_SIZE)
		{
			for (ProbeTexelCoord.x = GroupThreadId.x; ProbeTexelCoord.x < OutputIrradianceProbeResolution; ProbeTexelCoord.x += THREADGROUP_SIZE)
			{
				uint2 IrradianceAtlasCoord = ProbeTexelCoord + IrradianceBaseCoord;
				float3 Irradiance = FinalIrradianceAtlas[IrradianceAtlasCoord];

				if (ProbeCreatedFrame[ProbeIndex] != FrameNumber && LocalBlendSpeed < 1.0f)	
				{
					Irradiance = lerp(RWBlendedIrradianceAtlas[IrradianceAtlasCoord], Irradiance, LocalBlendSpeed);
				}

#define DEBUG_VISUALIZE_NEWLY_CREATED_PROBES 0
#if DEBUG_VISUALIZE_NEWLY_CREATED_PROBES
				if (ProbeCreatedFrame[ProbeIndex] == FrameNumber)
				{
					Irradiance = float3(1, 0, 0);
				}
#endif

				RWBlendedIrradianceAtlas[IrradianceAtlasCoord] = Irradiance;//QuantizeForFloatRenderTarget(Irradiance, int3(IrradianceAtlasCoord, FrameNumber));
			}
		}
		
		uint2 OcclusionBaseCoord = FinalOcclusionProbeResolution * ProbeCoord;

		for (ProbeTexelCoord.y = GroupThreadId.y; ProbeTexelCoord.y < FinalOcclusionProbeResolution; ProbeTexelCoord.y += THREADGROUP_SIZE)
		{
			for (ProbeTexelCoord.x = GroupThreadId.x; ProbeTexelCoord.x < FinalOcclusionProbeResolution; ProbeTexelCoord.x += THREADGROUP_SIZE)
			{
				uint2 OcclusionAtlasCoord = ProbeTexelCoord + OcclusionBaseCoord;
				float2 Occlusion = ProbeOcclusionAtlas[OcclusionAtlasCoord];

				if (ProbeCreatedFrame[ProbeIndex] != FrameNumber && LocalBlendSpeed < 1.0f)	
				{
					Occlusion = lerp(RWBlendedOcclusionAtlas[OcclusionAtlasCoord], Occlusion, LocalBlendSpeed);
				}			

				RWBlendedOcclusionAtlas[OcclusionAtlasCoord] = Occlusion;
			}
		}

		if (all(GroupThreadId.xy == uint2(0, 0)))
		{
			float3 ProbeOffset = ProbeWorldOffset[ProbeIndex].xyz;

			if (ProbeCreatedFrame[ProbeIndex] != FrameNumber && LocalBlendSpeed < 1.0f)	
			{
				ProbeOffset = lerp(RWBlendedProbeWorldOffset[ProbeIndex].xyz, ProbeOffset, LocalBlendSpeed);
			}			

			RWBlendedProbeWorldOffset[ProbeIndex] = float4(ProbeOffset, ProbeValid[ProbeIndex]);
		}
	}
}

#endif
